<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="目标检测,RCNN,Faster RCNN," />










<meta name="description" content="本文梳理GluonCV中Faster RCNN源码。">
<meta name="keywords" content="目标检测,RCNN,Faster RCNN">
<meta property="og:type" content="article">
<meta property="og:title" content="GluonCV中Faster-RCNN源码解读">
<meta property="og:url" content="flyrie.top/2018/06/17/GluonCV中Faster-RCNN源码解读/index.html">
<meta property="og:site_name" content="乡间小路">
<meta property="og:description" content="本文梳理GluonCV中Faster RCNN源码。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-04T02:18:16.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GluonCV中Faster-RCNN源码解读">
<meta name="twitter:description" content="本文梳理GluonCV中Faster RCNN源码。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="flyrie.top/2018/06/17/GluonCV中Faster-RCNN源码解读/"/>





  <title>GluonCV中Faster-RCNN源码解读 | 乡间小路</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?95d8d402b20d99d1e2e6f2de7b397428";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">乡间小路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="flyrie.top/2018/06/17/GluonCV中Faster-RCNN源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乡间小路">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乡间小路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GluonCV中Faster-RCNN源码解读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T01:46:14+08:00">
                2018-06-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-04T10:18:16+08:00">
                2018-07-04
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文梳理GluonCV中Faster RCNN源码。<a id="more"></a></p>
<h1 id="RPN网络"><a href="#RPN网络" class="headerlink" title="RPN网络"></a>RPN网络</h1><p>RPN网络由<code>RPN</code>这个类实现。主要包括生成anchors，得到score，bounding box回归，非极大值抑制。</p>
<ol>
<li>预生成大量的的anchors。在<code>RPNAnchorGenerator</code>里面实现。</li>
<li>根据feature map的尺寸slice相应数量的anchors。</li>
<li>使用 $1\times1$ 的卷积和sigmoid函数得到每个anchor是foregroud的分数。注意：原论文中对于每一个anchor会产生两个值，分别为foreground和background的分数，然后再用softmax，这点与Gluon-CV中的实现不一样，但效果一样。</li>
<li>使用 $1\times1$ 的卷积得到每个anchor的偏移值，以便之后做bounding box回归。</li>
<li>做非极大值抑制，按score从大到小的顺序得到前n个anchors的分数和坐标等信息。由<code>RPNProposal</code>这个类实现。</li>
</ol>
<p><code>RPN</code>类的代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPN</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">r"""Region Proposal Network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    channels : int</span></span><br><span class="line"><span class="string">        Channel number used in convolutional layers.</span></span><br><span class="line"><span class="string">    stride : int</span></span><br><span class="line"><span class="string">        Feature map stride with respect to original image.</span></span><br><span class="line"><span class="string">        This is usually the ratio between original image size and feature map size.</span></span><br><span class="line"><span class="string">    base_size : int</span></span><br><span class="line"><span class="string">        The width(and height) of reference anchor box.</span></span><br><span class="line"><span class="string">    ratios : iterable of float</span></span><br><span class="line"><span class="string">        The aspect ratios of anchor boxes. We expect it to be a list or tuple.</span></span><br><span class="line"><span class="string">    scales : iterable of float</span></span><br><span class="line"><span class="string">        The areas of anchor boxes.</span></span><br><span class="line"><span class="string">        We use the following form to compute the shapes of anchors:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. math::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            width_&#123;anchor&#125; = size_&#123;base&#125; \times scale \times \sqrt&#123; 1 / ratio&#125;</span></span><br><span class="line"><span class="string">            height_&#123;anchor&#125; = size_&#123;base&#125; \times scale \times \sqrt&#123;ratio&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    alloc_size : tuple of int</span></span><br><span class="line"><span class="string">        Allocate size for the anchor boxes as (H, W).</span></span><br><span class="line"><span class="string">        Usually we generate enough anchors for large feature map, e.g. 128x128.</span></span><br><span class="line"><span class="string">        Later in inference we can have variable input sizes,</span></span><br><span class="line"><span class="string">        at which time we can crop corresponding anchors from this large</span></span><br><span class="line"><span class="string">        anchor map so we can skip re-generating anchors for each input.</span></span><br><span class="line"><span class="string">    nms_thresh : float, default is 0.7</span></span><br><span class="line"><span class="string">        IOU threshold for NMS. It is used to remove overlapping proposals.</span></span><br><span class="line"><span class="string">    train_pre_nms : int, default is 12000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in training.</span></span><br><span class="line"><span class="string">    train_post_nms : int, default is 2000</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in training.</span></span><br><span class="line"><span class="string">    test_pre_nms : int, default is 6000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in testing.</span></span><br><span class="line"><span class="string">    test_post_nms : int, default is 300</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in testing.</span></span><br><span class="line"><span class="string">    min_size : int, default is 16</span></span><br><span class="line"><span class="string">        Proposals whose size is smaller than ``min_size`` will be discarded.</span></span><br><span class="line"><span class="string">    stds : tuple of float</span></span><br><span class="line"><span class="string">        Standard deviation to be multiplied from encoded regression targets.</span></span><br><span class="line"><span class="string">        These values must be the same as stds used in RPNTargetGenerator.</span></span><br><span class="line"><span class="string">    weight_initializer : mxnet.initializer, default is mx.init.Normal(0.01)</span></span><br><span class="line"><span class="string">        Weight intializer for RPN convolutional layers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, channels, stride, base_size=<span class="number">16</span>, ratios=<span class="params">(<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 scales=<span class="params">(<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>)</span>, alloc_size=<span class="params">(<span class="number">128</span>, <span class="number">128</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 nms_thresh=<span class="number">0.7</span>, train_pre_nms=<span class="number">12000</span>, train_post_nms=<span class="number">2000</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 test_pre_nms=<span class="number">6000</span>, test_post_nms=<span class="number">300</span>, min_size=<span class="number">16</span>, stds=<span class="params">(<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 weight_initializer=None, **kwargs)</span>:</span></span><br><span class="line">        super(RPN, self).__init__(**kwargs)</span><br><span class="line">        <span class="keyword">if</span> weight_initializer <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            weight_initializer = mx.init.Normal(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.anchor_generator = RPNAnchorGenerator(</span><br><span class="line">                stride, base_size, ratios, scales, alloc_size)</span><br><span class="line">            anchor_depth = self.anchor_generator.num_depth</span><br><span class="line">            self.region_proposaler = RPNProposal(</span><br><span class="line">                nms_thresh, train_pre_nms, train_post_nms,</span><br><span class="line">                test_pre_nms, test_post_nms, min_size, stds)</span><br><span class="line">            self.conv1 = nn.HybridSequential()</span><br><span class="line">            self.conv1.add(</span><br><span class="line">                nn.Conv2D(channels, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, weight_initializer=weight_initializer))</span><br><span class="line">            self.conv1.add(nn.Activation(<span class="string">'relu'</span>))</span><br><span class="line">            <span class="comment"># use sigmoid instead of softmax, reduce channel numbers</span></span><br><span class="line">            self.score = nn.Conv2D(anchor_depth, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, weight_initializer=weight_initializer)</span><br><span class="line">            self.loc = nn.Conv2D(anchor_depth * <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, weight_initializer=weight_initializer)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, x, img)</span>:</span></span><br><span class="line">        <span class="string">"""Forward RPN.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The behavior during traing and inference is different.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        x : mxnet.nd.NDArray or mxnet.symbol</span></span><br><span class="line"><span class="string">            Feature tensor.</span></span><br><span class="line"><span class="string">        img : mxnet.nd.NDArray or mxnet.symbol</span></span><br><span class="line"><span class="string">            The original input image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        (rpn_score, rpn_box)</span></span><br><span class="line"><span class="string">            Returns predicted scores and regions which are candidates of objects.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 生成anchors</span></span><br><span class="line">        anchors = self.anchor_generator(x)</span><br><span class="line">        <span class="comment"># 经过3*3的卷积，通道和宽高都没变</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="comment"># 经过1*1的卷积，通道变为anchor_depth，即为ratios*scales，然后再调整为batch*anchors*1</span></span><br><span class="line">        <span class="comment"># 然后经过sigmoid，得到是前景的分数，0-1之间</span></span><br><span class="line">        raw_rpn_scores = self.score(x).transpose(axes=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)).reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">        rpn_scores = F.sigmoid(raw_rpn_scores)</span><br><span class="line">        <span class="comment"># 经过1*1卷积，通道变为anchor_depth*4, 然后再调整为batch*ahchors*4</span></span><br><span class="line">        <span class="comment"># 得到的是bounding box regression的四个变换量</span></span><br><span class="line">        rpn_box_pred = self.loc(x).transpose(axes=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)).reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment"># 得到真正的符合条件的roi的score，坐标。在RPNProposal这个类里面实现（做了bounding box偏移和nms）。</span></span><br><span class="line">        <span class="comment"># self.region_proposaler的功能： </span></span><br><span class="line">        <span class="comment"># 1.做bounding box偏移 </span></span><br><span class="line">        <span class="comment"># 2.将超出图像像素的框clip到图像像素范围 </span></span><br><span class="line">        <span class="comment"># 3.滤掉宽高小于一定阈值的box </span></span><br><span class="line">        <span class="comment"># 4.做nms </span></span><br><span class="line">        <span class="comment"># 5.从nms的结果中得到前n个box的scor和坐标</span></span><br><span class="line">        <span class="comment"># 所以加入输入的有m个box，但输出的只有n个，训练是是2000个</span></span><br><span class="line">        rpn_score, rpn_box = self.region_proposaler(</span><br><span class="line">            anchors, rpn_scores, rpn_box_pred, img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果是训练，返回（给sampler的box的分数，给sampler的box的坐标，原始anchor的score，预测的anchors偏移，原始的anchors）</span></span><br><span class="line">        <span class="keyword">if</span> autograd.is_training():</span><br><span class="line">            <span class="comment"># return raw predictions as well in training for bp</span></span><br><span class="line">            <span class="keyword">return</span> rpn_score, rpn_box, raw_rpn_scores, rpn_box_pred, anchors</span><br><span class="line">        <span class="comment"># 如果是做预测，返回roi的score和坐标</span></span><br><span class="line">        <span class="keyword">return</span> rpn_score, rpn_box</span><br></pre></td></tr></table></figure></p>
<h2 id="生成anchors"><a href="#生成anchors" class="headerlink" title="生成anchors"></a>生成anchors</h2><p>anchors生成的总体思路是，初始化的时候先在 $128\times128$ 尺寸的特征图上预生成所有的anchors。之后在计算输入图像的anchors时，只需slice相应的尺寸，这样避免做不必要的重复生成操作。</p>
<p>预生成操作的代码为<code>anchors = self._generate_anchors(stride, base_size, ratios, scales, alloc_size)</code>。slice操作的代码为<code>a = F.slice_like(anchors, x * 0, axes=(2, 3))</code>。</p>
<p>例如，anchors有5种像素，3种宽高比，则特征图上每个像素会生成15个anchors，大小为 $15\times4$。$128\times128$的像素中，预生成的anchors尺寸大小是 $128\times128\times60$。如果真正图像的feature map的空间尺寸为 $38\times50$，那么只需在预生成的anchors中slice $38\times50$ 大小的anchors即可，即 $38\times50\times60$。</p>
<p>需要注意的是，初始化中有一个参数<code>stride</code>，它的具体含义是原图空间尺寸和feature map的空间尺寸之比。例如原图的尺寸是 $512\times512$，经过CNN网络之后，feature map的大小为 $32\times32$，缩放了16倍，则stride为16。这样做的目的是为了可以从feature map对应到原始图像。</p>
<h2 id="RPNProposal类详解"><a href="#RPNProposal类详解" class="headerlink" title="RPNProposal类详解"></a><code>RPNProposal</code>类详解</h2><p><code>RPNProposal</code>这个类主要是用来产生ROI（Region of interest）。  </p>
<ol>
<li>先做一个bounding box regression，但是这里没有单独的loss，实际上只是通过前面CNN生成的bbox_pred，将anchors进行一个平移加缩放。代码为<code>roi = self._box_decoder(bbox_pred, self._box_to_center(anchor))</code>。</li>
<li>将超出原图像素范围的anchors的clip到原图像素范围。例如某个anchor为[-33, -12, 877, 912]，而原图像素为 $600\times800$，则把anchor变为[0, 0, 799, 599]，代码为<code>roi = F.Custom(roi, img, op_type=&#39;bbox_clip_to_image&#39;)</code>。</li>
<li>将宽度或者高度小于某个阈值的anchors的score变为0，坐标变为-1，目的是剔除这些anchors。 </li>
<li>做nms。会将小于阈值的anchors的score变为-1，坐标也变为-1，并且按照score从大到小排序。</li>
<li>从nms得到的anchors中找出取前n个，返回其score和坐标。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPNProposal</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">"""Proposal generator for RPN.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    RPNProposal takes RPN anchors, RPN prediction scores and box regression preditions.</span></span><br><span class="line"><span class="string">    It will transform anchors, apply NMS to get clean foreground proposals.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    nms_thresh : float, default is 0.7</span></span><br><span class="line"><span class="string">        IOU threshold for NMS. It is used to remove overlapping proposals.</span></span><br><span class="line"><span class="string">    train_pre_nms : int, default is 12000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in training.</span></span><br><span class="line"><span class="string">    train_post_nms : int, default is 2000</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in training.</span></span><br><span class="line"><span class="string">    test_pre_nms : int, default is 6000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in testing.</span></span><br><span class="line"><span class="string">    test_post_nms : int, default is 300</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in testing.</span></span><br><span class="line"><span class="string">    min_size : int, default is 16</span></span><br><span class="line"><span class="string">        Proposals whose size is smaller than ``min_size`` will be discarded.</span></span><br><span class="line"><span class="string">    stds : tuple of float</span></span><br><span class="line"><span class="string">        Standard deviation to be multiplied from encoded regression targets.</span></span><br><span class="line"><span class="string">        These values must be the same as stds used in RPNTargetGenerator.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nms_thresh=<span class="number">0.7</span>, train_pre_nms=<span class="number">12000</span>, train_post_nms=<span class="number">2000</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 test_pre_nms=<span class="number">6000</span>, test_post_nms=<span class="number">300</span>, min_size=<span class="number">16</span>, stds=<span class="params">(<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)</span>)</span>:</span></span><br><span class="line">        super(RPNProposal, self).__init__()</span><br><span class="line">        self._box_to_center = BBoxCornerToCenter()</span><br><span class="line">        self._box_decoder = NormalizedBoxCenterDecoder(stds=stds)</span><br><span class="line">        <span class="comment"># self._clipper = BBoxClipToImage()</span></span><br><span class="line">        <span class="comment"># self._compute_area = BBoxArea()</span></span><br><span class="line">        self._nms_thresh = nms_thresh</span><br><span class="line">        self._train_pre_nms = max(<span class="number">1</span>, train_pre_nms)</span><br><span class="line">        self._train_post_nms = max(<span class="number">1</span>, train_post_nms)</span><br><span class="line">        self._test_pre_nms = max(<span class="number">1</span>, test_pre_nms)</span><br><span class="line">        self._test_post_nms = max(<span class="number">1</span>, test_post_nms)</span><br><span class="line">        self._min_size = min_size</span><br><span class="line"></span><br><span class="line">    <span class="comment">#pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, anchor, score, bbox_pred, img)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Generate proposals. Limit to batch-size=1 in current implementation.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> autograd.is_training():</span><br><span class="line">            pre_nms = self._train_pre_nms</span><br><span class="line">            post_nms = self._train_post_nms</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre_nms = self._test_pre_nms</span><br><span class="line">            post_nms = self._test_post_nms</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> autograd.pause():</span><br><span class="line">            <span class="comment"># restore bounding boxes</span></span><br><span class="line">            <span class="comment"># self._box_to_center将anchor从(xmin, ymin, xmax, ymax)的形式转换为(center_x, center_y, width, height)的形式</span></span><br><span class="line">            <span class="comment"># self._box_decoder做平移和缩放，即bounding box regression</span></span><br><span class="line">            roi = self._box_decoder(bbox_pred, self._box_to_center(anchor))</span><br><span class="line">            <span class="comment"># clip rois to image's boundary</span></span><br><span class="line">            <span class="comment"># 将超出原图像素范围的anchors的clip到原图像素范围</span></span><br><span class="line">            roi = F.Custom(roi, img, op_type=<span class="string">'bbox_clip_to_image'</span>)</span><br><span class="line">            <span class="comment"># roi = self._clipper(roi, width, height)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># remove bounding boxes that don't meet the min_size constraint</span></span><br><span class="line">            <span class="comment"># by setting them to (-1, -1, -1, -1)</span></span><br><span class="line">            <span class="comment"># width = roi.slice_axis(axis=-1, begin=2, end=3)</span></span><br><span class="line">            <span class="comment"># height = roi.slice_axis(axis=-1, begin=3, end=None)</span></span><br><span class="line">            xmin, ymin, xmax, ymax = roi.split(axis=<span class="number">-1</span>, num_outputs=<span class="number">4</span>)</span><br><span class="line">            <span class="comment"># 计算所有anchors的宽高</span></span><br><span class="line">            width = xmax - xmin</span><br><span class="line">            height = ymax - ymin</span><br><span class="line">            <span class="comment"># <span class="doctag">TODO:</span>(zhreshold), there's im_ratio to handle here, but it requires</span></span><br><span class="line">            <span class="comment"># add' info, and we don't expect big difference</span></span><br><span class="line">            <span class="comment"># 找出所有宽或高小于self._min_size的anchors，用&gt;0表示，其他的都是0</span></span><br><span class="line">            invalid = (width &lt; self._min_size) + (height &lt; self._min_size)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># # remove out of bound anchors</span></span><br><span class="line">            <span class="comment"># axmin, aymin, axmax, aymax = F.split(anchor, axis=-1, num_outputs=4)</span></span><br><span class="line">            <span class="comment"># # it's a bit tricky to get right/bottom boundary in hybridblock</span></span><br><span class="line">            <span class="comment"># wrange = F.arange(0, 2560).reshape((1, 1, 1, 2560)).slice_like(</span></span><br><span class="line">            <span class="comment">#    img, axes=(3)).max().reshape((1, 1, 1))</span></span><br><span class="line">            <span class="comment"># hrange = F.arange(0, 2560).reshape((1, 1, 2560, 1)).slice_like(</span></span><br><span class="line">            <span class="comment">#    img, axes=(2)).max().reshape((1, 1, 1))</span></span><br><span class="line">            <span class="comment"># invalid = (axmin &lt; 0) + (aymin &lt; 0) + F.broadcast_greater(axmax, wrange) + \</span></span><br><span class="line">            <span class="comment">#    F.broadcast_greater(aymax, hrange)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每个invalid对应的anchors的score变为0</span></span><br><span class="line">            score = F.where(invalid, F.zeros_like(invalid), score)</span><br><span class="line">            <span class="comment"># 将invalid复制四份，即最后一个维度为4，因为roi的最后一个维度也是4</span></span><br><span class="line">            invalid = F.repeat(invalid, axis=<span class="number">-1</span>, repeats=<span class="number">4</span>)</span><br><span class="line">            <span class="comment"># 每个invalid对应的anchors的roi变为-1，（注意：不能变成0，因为roi里面本来就有0元素）</span></span><br><span class="line">            roi = F.where(invalid, F.ones_like(invalid) * <span class="number">-1</span>, roi)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Non-maximum suppression</span></span><br><span class="line">            <span class="comment"># 将score和roi拼接在一起，最后一个维度上，第一个元素代表score，后面四个元素代表坐标</span></span><br><span class="line">            pre = F.concat(score, roi, dim=<span class="number">-1</span>)</span><br><span class="line">            <span class="comment"># 做非极大值抑制，按score从大到小排列，并且会将小于阈值的的score和坐标变为-1</span></span><br><span class="line">            tmp = F.contrib.box_nms(pre, overlap_thresh=self._nms_thresh, topk=pre_nms,</span><br><span class="line">                                    coord_start=<span class="number">1</span>, score_index=<span class="number">0</span>, id_index=<span class="number">-1</span>, force_suppress=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># slice post_nms number of boxes</span></span><br><span class="line">            <span class="comment"># 选前post_nms个候选框</span></span><br><span class="line">            result = F.slice_axis(tmp, axis=<span class="number">1</span>, begin=<span class="number">0</span>, end=post_nms)</span><br><span class="line">            <span class="comment"># 得到这些候选框的score</span></span><br><span class="line">            rpn_scores = F.slice_axis(result, axis=<span class="number">-1</span>, begin=<span class="number">0</span>, end=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 得到这些候选框的坐标</span></span><br><span class="line">            rpn_bbox = F.slice_axis(result, axis=<span class="number">-1</span>, begin=<span class="number">1</span>, end=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rpn_scores, rpn_bbox</span><br></pre></td></tr></table></figure>
<h2 id="RCNNTargetSampler"><a href="#RCNNTargetSampler" class="headerlink" title="RCNNTargetSampler"></a>RCNNTargetSampler</h2><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p>得到每个box最大iou的索引，并且要大于<code>self._threshold</code>，阈值默认0.7，如果小于就为-1。<br>例如，输入：x=[[0, 0, 0.3], [0.8, 0, 0.1], [0.2, 0.1, 0.9]]，输出：[-1, 0, 2]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumMatcher</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">"""A Matcher implementing maximum matching strategy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    threshold : float</span></span><br><span class="line"><span class="string">        Matching threshold.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threshold)</span>:</span></span><br><span class="line">        super(MaximumMatcher, self).__init__()</span><br><span class="line">        self._threshold = threshold</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, x)</span>:</span></span><br><span class="line">        <span class="comment"># x保存的是每个roi与每个gt_box的iou，例如两个roi，3个gt_box，则为[[0, 0, 0.3], [0.6, 0, 0.1]]</span></span><br><span class="line">        <span class="comment"># argmax得到与那个gt_box的iou最大，对应的索引，如返回[2, 0]</span></span><br><span class="line">        argmax = F.argmax(x, axis=<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># F.pick(x, argmax, axis=-1)按照argmax的索引获取对应的值</span></span><br><span class="line">        <span class="comment"># &gt;= self._threshold=0.7 与上一步得到的值比较，得到0 1矩阵</span></span><br><span class="line">        <span class="comment"># F.where()按照上一步得到的0 1矩阵，得到每个roi和哪个gt_box的iou最大，如果是0就复制为-1</span></span><br><span class="line">        <span class="comment"># match最终得到roi和哪个gt_box的iou最大，如果iou小于阈值，则对应位置的值为-1</span></span><br><span class="line">        match = F.where(F.pick(x, argmax, axis=<span class="number">-1</span>) &gt;= self._threshold, argmax,</span><br><span class="line">                        F.ones_like(argmax) * <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> match</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCNNTargetSampler</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">"""A sampler to choose positive/negative samples from RCNN Proposals</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    num_sample : int, default is 128</span></span><br><span class="line"><span class="string">        Number of samples for RCNN targets.</span></span><br><span class="line"><span class="string">    pos_iou_thresh : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU larger than ``pos_iou_thresh`` is regarded as positive samples.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_high : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU smaller than ``neg_iou_thresh_high``</span></span><br><span class="line"><span class="string">        and larger than ``neg_iou_thresh_low``</span></span><br><span class="line"><span class="string">        is regarded as negative samples.</span></span><br><span class="line"><span class="string">        Proposals with IOU in between ``pos_iou_thresh`` and ``neg_iou_thresh`` are</span></span><br><span class="line"><span class="string">        ignored.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_low : float, default is 0.0</span></span><br><span class="line"><span class="string">        See ``neg_iou_thresh_high``.</span></span><br><span class="line"><span class="string">    pos_ratio : float, default is 0.25</span></span><br><span class="line"><span class="string">        ``pos_ratio`` defines how many positive samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sample=<span class="number">128</span>, pos_iou_thresh=<span class="number">0.5</span>, neg_iou_thresh_high=<span class="number">0.5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 neg_iou_thresh_low=<span class="number">0.0</span>, pos_ratio=<span class="number">0.25</span>)</span>:</span></span><br><span class="line">        super(RCNNTargetSampler, self).__init__()</span><br><span class="line">        self._num_sample = num_sample</span><br><span class="line">        self._pos_iou_thresh = pos_iou_thresh</span><br><span class="line">        self._neg_iou_thresh_high = neg_iou_thresh_high</span><br><span class="line">        self._neg_iou_thresh_low = neg_iou_thresh_low</span><br><span class="line">        self._pos_ratio = pos_ratio</span><br><span class="line">        self._matcher = MaximumMatcher(pos_iou_thresh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, roi, gt_box)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Only support batch_size=1 now.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> autograd.pause():</span><br><span class="line">            <span class="comment"># cocnat rpn roi with ground truths</span></span><br><span class="line">            <span class="comment"># 去掉axis=0这个单维度，并且合并roi和gtbox</span></span><br><span class="line">            all_roi = F.concat(roi.squeeze(axis=<span class="number">0</span>), gt_box.squeeze(axis=<span class="number">0</span>), dim=<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># calculate ious between (N, 4) anchors and (M, 4) bbox ground-truths</span></span><br><span class="line">            <span class="comment"># ious is (N, M)</span></span><br><span class="line">            <span class="comment"># 计算all_roi与每个gt_box的ious，</span></span><br><span class="line">            ious = F.contrib.box_iou(all_roi, gt_box, format=<span class="string">'corner'</span>).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">            <span class="comment"># 得到每个roi最大的iou值，具体里面会有一个阈值，iou小于阈值的roi赋值为-1</span></span><br><span class="line">            matches = self._matcher(ious)</span><br><span class="line">            <span class="comment"># 得到哪些是负样本-1，哪些是正样本1，哪些需要忽略0</span></span><br><span class="line">            samples = F.Custom(matches, ious, op_type=<span class="string">'quota_sampler'</span>,</span><br><span class="line">                               num_sample=self._num_sample,</span><br><span class="line">                               pos_thresh=self._pos_iou_thresh,</span><br><span class="line">                               neg_thresh_high=self._neg_iou_thresh_high,</span><br><span class="line">                               neg_thresh_low=self._neg_iou_thresh_low,</span><br><span class="line">                               pos_ratio=self._pos_ratio)</span><br><span class="line">            <span class="comment"># 上一步得到的是类似这样的矩阵[[-1, 0, 1, 0, ...]]， 把第一个单维度去掉</span></span><br><span class="line">            samples = samples.squeeze(axis=<span class="number">0</span>)   <span class="comment"># remove batch axis</span></span><br><span class="line">            <span class="comment"># 之前的matchs得到的是这样的矩阵[[-1, -1, -1, 3, 4, -1,...]]，把第一个维度去掉</span></span><br><span class="line">            matches = matches.squeeze(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># shuffle and argsort, take first num_sample samples</span></span><br><span class="line">            <span class="comment"># 将samples中为0的值（需要忽略的roi）变为-999，并且赋值给sf_samples</span></span><br><span class="line">            sf_samples = F.where(samples == <span class="number">0</span>, F.ones_like(samples) * <span class="number">-999</span>, samples)</span><br><span class="line">            <span class="comment"># F.argsort得到sf_samples从小到大排序的索引，slice_axis得到前self._num_sample个index</span></span><br><span class="line">            indices = F.argsort(sf_samples, is_ascend=<span class="keyword">False</span>).slice_axis(</span><br><span class="line">                axis=<span class="number">0</span>, begin=<span class="number">0</span>, end=self._num_sample)</span><br><span class="line">            <span class="comment"># 从all_roi中将对应indices的元素拿出来，再加上一个维度</span></span><br><span class="line">            new_roi = all_roi.take(indices).expand_dims(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 从samples中将对应indices的元素拿出来，再加上一个维度</span></span><br><span class="line">            new_samples = samples.take(indices).expand_dims(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 从matchs中得到对应indices的元素，再加上一个维度</span></span><br><span class="line">            new_matches = matches.take(indices).expand_dims(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> new_roi, new_samples, new_matches</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FasterRCNN</span><span class="params">(RCNN)</span>:</span></span><br><span class="line">    <span class="string">r"""Faster RCNN network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    features : gluon.HybridBlock</span></span><br><span class="line"><span class="string">        Base feature extractor before feature pooling layer.</span></span><br><span class="line"><span class="string">    top_features : gluon.HybridBlock</span></span><br><span class="line"><span class="string">        Tail feature extractor after feature pooling layer.</span></span><br><span class="line"><span class="string">    train_patterns : str</span></span><br><span class="line"><span class="string">        Matching pattern for trainable parameters.</span></span><br><span class="line"><span class="string">    scales : iterable of float</span></span><br><span class="line"><span class="string">        The areas of anchor boxes.</span></span><br><span class="line"><span class="string">        We use the following form to compute the shapes of anchors:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. math::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            width_&#123;anchor&#125; = size_&#123;base&#125; \times scale \times \sqrt&#123; 1 / ratio&#125;</span></span><br><span class="line"><span class="string">            height_&#123;anchor&#125; = size_&#123;base&#125; \times scale \times \sqrt&#123;ratio&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ratios : iterable of float</span></span><br><span class="line"><span class="string">        The aspect ratios of anchor boxes. We expect it to be a list or tuple.</span></span><br><span class="line"><span class="string">    classes : iterable of str</span></span><br><span class="line"><span class="string">        Names of categories, its length is ``num_class``.</span></span><br><span class="line"><span class="string">    roi_mode : str</span></span><br><span class="line"><span class="string">        ROI pooling mode. Currently support 'pool' and 'align'.</span></span><br><span class="line"><span class="string">    roi_size : tuple of int, length 2</span></span><br><span class="line"><span class="string">        (height, width) of the ROI region.</span></span><br><span class="line"><span class="string">    stride : int, default is 16</span></span><br><span class="line"><span class="string">        Feature map stride with respect to original image.</span></span><br><span class="line"><span class="string">        This is usually the ratio between original image size and feature map size.</span></span><br><span class="line"><span class="string">    rpn_channel : int, default is 1024</span></span><br><span class="line"><span class="string">        Channel number used in RPN convolutional layers.</span></span><br><span class="line"><span class="string">    rpn_train_pre_nms : int, default is 12000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in training of RPN.</span></span><br><span class="line"><span class="string">    rpn_train_post_nms : int, default is 2000</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in training of RPN.</span></span><br><span class="line"><span class="string">    rpn_test_pre_nms : int, default is 6000</span></span><br><span class="line"><span class="string">        Filter top proposals before NMS in testing of RPN.</span></span><br><span class="line"><span class="string">    rpn_test_post_nms : int, default is 300</span></span><br><span class="line"><span class="string">        Return top proposal results after NMS in testing of RPN.</span></span><br><span class="line"><span class="string">    nms_thresh : float, default is 0.3.</span></span><br><span class="line"><span class="string">        Non-maximum suppression threshold. You can speficy &lt; 0 or &gt; 1 to disable NMS.</span></span><br><span class="line"><span class="string">    nms_topk : int, default is 400</span></span><br><span class="line"><span class="string">        Apply NMS to top k detection results, use -1 to disable so that every Detection</span></span><br><span class="line"><span class="string">         result is used in NMS.</span></span><br><span class="line"><span class="string">    post_nms : int, default is 100</span></span><br><span class="line"><span class="string">        Only return top `post_nms` detection results, the rest is discarded. The number is</span></span><br><span class="line"><span class="string">        based on COCO dataset which has maximum 100 objects per image. You can adjust this</span></span><br><span class="line"><span class="string">        number if expecting more objects. You can use -1 to return all detections.</span></span><br><span class="line"><span class="string">    num_sample : int, default is 128</span></span><br><span class="line"><span class="string">        Number of samples for RCNN targets.</span></span><br><span class="line"><span class="string">    pos_iou_thresh : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU larger than ``pos_iou_thresh`` is regarded as positive samples.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_high : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU smaller than ``neg_iou_thresh_high``</span></span><br><span class="line"><span class="string">        and larger than ``neg_iou_thresh_low`` is regarded as negative samples.</span></span><br><span class="line"><span class="string">        Proposals with IOU in between ``pos_iou_thresh`` and ``neg_iou_thresh`` are</span></span><br><span class="line"><span class="string">        ignored.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_low : float, default is 0.0</span></span><br><span class="line"><span class="string">        See ``neg_iou_thresh_high``.</span></span><br><span class="line"><span class="string">    pos_ratio : float, default is 0.25</span></span><br><span class="line"><span class="string">        ``pos_ratio`` defines how many positive samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, features, top_features, scales, ratios, classes, roi_mode, roi_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stride=<span class="number">16</span>, rpn_channel=<span class="number">1024</span>, rpn_train_pre_nms=<span class="number">12000</span>, rpn_train_post_nms=<span class="number">2000</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 rpn_test_pre_nms=<span class="number">6000</span>, rpn_test_post_nms=<span class="number">300</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 num_sample=<span class="number">128</span>, pos_iou_thresh=<span class="number">0.5</span>, neg_iou_thresh_high=<span class="number">0.5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 neg_iou_thresh_low=<span class="number">0.0</span>, pos_ratio=<span class="number">0.25</span>, **kwargs)</span>:</span></span><br><span class="line">        super(FasterRCNN, self).__init__(</span><br><span class="line">            features, top_features, classes, roi_mode, roi_size, **kwargs)</span><br><span class="line">        self.stride = stride</span><br><span class="line">        self._max_batch = <span class="number">1</span>  <span class="comment"># currently only support batch size = 1</span></span><br><span class="line">        self._max_roi = <span class="number">100000</span>  <span class="comment"># maximum allowed ROIs</span></span><br><span class="line">        self._target_generator = set([RCNNTargetGenerator(self.num_class)])</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.rpn = RPN(rpn_channel, stride, scales=scales, ratios=ratios,</span><br><span class="line">                           train_pre_nms=rpn_train_pre_nms, train_post_nms=rpn_train_post_nms,</span><br><span class="line">                           test_pre_nms=rpn_test_pre_nms, test_post_nms=rpn_test_post_nms)</span><br><span class="line">            self.sampler = RCNNTargetSampler(num_sample, pos_iou_thresh, neg_iou_thresh_high,</span><br><span class="line">                                             neg_iou_thresh_low, pos_ratio)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">target_generator</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Returns stored target generator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        mxnet.gluon.HybridBlock</span></span><br><span class="line"><span class="string">            The RCNN target generator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> list(self._target_generator)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, x, gt_box=None)</span>:</span></span><br><span class="line">        <span class="string">"""Forward Faster-RCNN network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The behavior during traing and inference is different.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        x : mxnet.nd.NDArray or mxnet.symbol</span></span><br><span class="line"><span class="string">            The network input tensor.</span></span><br><span class="line"><span class="string">        gt_box : type, only required during training</span></span><br><span class="line"><span class="string">            The ground-truth bbox tensor with shape (1, N, 4).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns</span></span><br><span class="line"><span class="string">        -------</span></span><br><span class="line"><span class="string">        (ids, scores, bboxes)</span></span><br><span class="line"><span class="string">            During inference, returns final class id, confidence scores, bounding</span></span><br><span class="line"><span class="string">            boxes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        feat = self.features(x)</span><br><span class="line">        <span class="comment"># RPN proposals</span></span><br><span class="line">        <span class="keyword">if</span> autograd.is_training():</span><br><span class="line">            <span class="comment"># rpn网络的输出，例如</span></span><br><span class="line">            <span class="comment"># rpn_box shape 1*2000*4</span></span><br><span class="line">            <span class="comment"># raw_rpn_score shape 1*28500*1</span></span><br><span class="line">            <span class="comment"># raw_rpn_box shape 1*28500*4</span></span><br><span class="line">            <span class="comment"># anchors shape 1*28500*4</span></span><br><span class="line">            _, rpn_box, raw_rpn_score, raw_rpn_box, anchors = self.rpn(</span><br><span class="line">                feat, F.zeros_like(x))</span><br><span class="line">            <span class="comment"># sample 128 roi</span></span><br><span class="line">            <span class="keyword">assert</span> gt_box <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">            <span class="comment"># rpn_box：加上样本lebel之后选出的rpn_box，例如shape=1*128*4  </span></span><br><span class="line">            <span class="comment"># samples：得到rpn_box是正样本1，还是负样本-1，还是忽略0 例如 shape=1*128</span></span><br><span class="line">            <span class="comment"># matches：rpn_box匹配哪个样本，-1代表忽略的，其他值是真是的 例如 shape=1*128</span></span><br><span class="line">            rpn_box, samples, matches = self.sampler(rpn_box, gt_box)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _, rpn_box = self.rpn(feat, F.zeros_like(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create batchid for roi</span></span><br><span class="line">        <span class="keyword">with</span> autograd.pause():</span><br><span class="line">            <span class="comment"># 例如self._max_batch是1，self._max_roi是3，则产生如下[[0, 0, 0]]</span></span><br><span class="line">            roi_batchid = F.arange(</span><br><span class="line">                <span class="number">0</span>, self._max_batch, repeat=self._max_roi).reshape(</span><br><span class="line">                    (<span class="number">-1</span>, self._max_roi))</span><br><span class="line">            <span class="comment"># roi_batchid变成和rpn_box数量一致，例如shape 1*128</span></span><br><span class="line">            roi_batchid = F.slice_like(roi_batchid, rpn_box * <span class="number">0</span>, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># rpn_roi把roi_batchid和rpn_box连接在一起，例如 shape为128*5，这样是之后接口中rpn_box第二个维度上有五个值</span></span><br><span class="line">            rpn_roi = F.concat(*[roi_batchid.reshape((<span class="number">-1</span>, <span class="number">1</span>)), rpn_box.reshape((<span class="number">-1</span>, <span class="number">4</span>))], dim=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ROI features</span></span><br><span class="line">        <span class="comment"># 做roi pooling layer，得到固定空间大小的特征输出，如有128个roi，feature map的通道是1024，空间大小是14*14，那么得到的输出shape是128*1024*14*14</span></span><br><span class="line">        <span class="keyword">if</span> self._roi_mode == <span class="string">'pool'</span>:</span><br><span class="line">            pooled_feat = F.ROIPooling(feat, rpn_roi, self._roi_size, <span class="number">1.</span> / self.stride)</span><br><span class="line">        <span class="keyword">elif</span> self._roi_mode == <span class="string">'align'</span>:</span><br><span class="line">            pooled_feat = F.contrib.ROIAlign(feat, rpn_roi, self._roi_size, <span class="number">1.</span> / self.stride)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Invalid roi mode: &#123;&#125;"</span>.format(self._roi_mode))</span><br><span class="line">        <span class="comment"># RCNN prediction</span></span><br><span class="line">        <span class="comment"># 再次用卷积网络提取特征，例如shape从128*1024*14*14变为128*2048*7*7的shape</span></span><br><span class="line">        top_feat = self.top_features(pooled_feat)</span><br><span class="line">        <span class="comment"># top_feat = F.Pooling(top_feat, global_pool=True, pool_type='avg', kernel=self._roi_size)</span></span><br><span class="line">        <span class="comment"># 在top_feat上面做一个全局平均，例如shape变为128*2048*1*1</span></span><br><span class="line">        top_feat = self.global_avg_pool(top_feat)</span><br><span class="line">        <span class="comment"># 接全连接网络预测类别，例如shape变为128*21</span></span><br><span class="line">        cls_pred = self.class_predictor(top_feat)</span><br><span class="line">        <span class="comment"># 接全连接网络预测bounding box，例如shape变为20*128*4</span></span><br><span class="line">        box_pred = self.box_predictor(top_feat).reshape(</span><br><span class="line">            (<span class="number">-1</span>, self.num_class, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># no need to convert bounding boxes in training, just return</span></span><br><span class="line">        <span class="comment"># 训练过程中，返回如下</span></span><br><span class="line">        <span class="comment"># cls_pred：全连接网络最后的预测类型</span></span><br><span class="line">        <span class="comment"># box_pred: 全连接网络最后的box偏移</span></span><br><span class="line">        <span class="comment"># rpn_box：加上lebal的所有box偏移</span></span><br><span class="line">        <span class="comment"># samples：rpn_box是正样本1，还是负样本-1，还是忽略0</span></span><br><span class="line">        <span class="comment"># matches：rpn_box匹配哪个样本，-1代表忽略的，其他值是真实类别</span></span><br><span class="line">        <span class="comment"># raw_rpn_score：原始产生的boxscore</span></span><br><span class="line">        <span class="comment"># raw_rpn_box：原始产生的box坐标偏移</span></span><br><span class="line">        <span class="comment"># anchors：原始产生的anchors</span></span><br><span class="line">        <span class="keyword">if</span> autograd.is_training():</span><br><span class="line">            box_pred = box_pred.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> (cls_pred, box_pred, rpn_box, samples, matches,</span><br><span class="line">                    raw_rpn_score, raw_rpn_box, anchors)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># translate bboxes</span></span><br><span class="line">        bboxes = self.box_decoder(box_pred, self.box_to_center(rpn_box)).split(</span><br><span class="line">            axis=<span class="number">0</span>, num_outputs=self.num_class, squeeze_axis=<span class="keyword">True</span>)</span><br><span class="line">        cls_ids, scores = self.cls_decoder(F.softmax(cls_pred, axis=<span class="number">-1</span>))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_class):</span><br><span class="line">            cls_id = cls_ids.slice_axis(axis=<span class="number">-1</span>, begin=i, end=i+<span class="number">1</span>)</span><br><span class="line">            score = scores.slice_axis(axis=<span class="number">-1</span>, begin=i, end=i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># per class results</span></span><br><span class="line">            per_result = F.concat(*[cls_id, score, bboxes[i]], dim=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            results.append(per_result)</span><br><span class="line">        result = F.concat(*results, dim=<span class="number">0</span>).expand_dims(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> self.nms_thresh &gt; <span class="number">0</span> <span class="keyword">and</span> self.nms_thresh &lt; <span class="number">1</span>:</span><br><span class="line">            result = F.contrib.box_nms(</span><br><span class="line">                result, overlap_thresh=self.nms_thresh, topk=self.nms_topk,</span><br><span class="line">                id_index=<span class="number">0</span>, score_index=<span class="number">1</span>, coord_start=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> self.post_nms &gt; <span class="number">0</span>:</span><br><span class="line">                result = result.slice_axis(axis=<span class="number">1</span>, begin=<span class="number">0</span>, end=self.post_nms).squeeze(axis=<span class="number">0</span>)</span><br><span class="line">        ids = F.slice_axis(result, axis=<span class="number">-1</span>, begin=<span class="number">0</span>, end=<span class="number">1</span>)</span><br><span class="line">        scores = F.slice_axis(result, axis=<span class="number">-1</span>, begin=<span class="number">1</span>, end=<span class="number">2</span>)</span><br><span class="line">        bboxes = F.slice_axis(result, axis=<span class="number">-1</span>, begin=<span class="number">2</span>, end=<span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span> ids, scores, bboxes</span><br></pre></td></tr></table></figure>
<h1 id="target怎么来"><a href="#target怎么来" class="headerlink" title="target怎么来"></a>target怎么来</h1><p>在<code>FasterRCNNDefaultTrainTransform</code>这个类的call方法里面。  </p>
<ol>
<li>先将img resize到输入网络的尺寸，如<code>600*800</code>；然后img随机翻转，gt_box也做相应翻转；</li>
<li>输入中有net的信息，就可以知道img经过net之后的feature map大小，如<code>1024*38*50</code>；</li>
<li>从预生成的anchors中slice相应的anchors；</li>
<li>计算anchors与gt_box之间的iou；</li>
<li>根据iou信息最终得到 box_target：正样本box跟gt_box之间要学习的平移和缩放距离；box_mask：box_target对应的mask；cls_target：哪些是正样本，哪些是负样本，哪些需要忽略。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FasterRCNNDefaultTrainTransform</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Default Faster-RCNN training transform.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    short : int, default is 600</span></span><br><span class="line"><span class="string">        Resize image shorter side to ``short``.</span></span><br><span class="line"><span class="string">    max_size : int, default is 1000</span></span><br><span class="line"><span class="string">        Make sure image longer side is smaller than ``max_size``.</span></span><br><span class="line"><span class="string">    net : mxnet.gluon.HybridBlock, optional</span></span><br><span class="line"><span class="string">        The faster-rcnn network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. hint::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            If net is ``None``, the transformation will not generate training targets.</span></span><br><span class="line"><span class="string">            Otherwise it will generate training targets to accelerate the training phase</span></span><br><span class="line"><span class="string">            since we push some workload to CPU workers instead of GPUs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mean : array-like of size 3</span></span><br><span class="line"><span class="string">        Mean pixel values to be subtracted from image tensor. Default is [0.485, 0.456, 0.406].</span></span><br><span class="line"><span class="string">    std : array-like of size 3</span></span><br><span class="line"><span class="string">        Standard deviation to be divided from image. Default is [0.229, 0.224, 0.225].</span></span><br><span class="line"><span class="string">    box_norm : array-like of size 4, default is (1., 1., 1., 1.)</span></span><br><span class="line"><span class="string">        Std value to be divided from encoded values.</span></span><br><span class="line"><span class="string">    num_sample : int, default is 256</span></span><br><span class="line"><span class="string">        Number of samples for RPN targets.</span></span><br><span class="line"><span class="string">    pos_iou_thresh : float, default is 0.7</span></span><br><span class="line"><span class="string">        Anchors larger than ``pos_iou_thresh`` is regarded as positive samples.</span></span><br><span class="line"><span class="string">    neg_iou_thresh : float, default is 0.3</span></span><br><span class="line"><span class="string">        Anchors smaller than ``neg_iou_thresh`` is regarded as negative samples.</span></span><br><span class="line"><span class="string">        Anchors with IOU in between ``pos_iou_thresh`` and ``neg_iou_thresh`` are</span></span><br><span class="line"><span class="string">        ignored.</span></span><br><span class="line"><span class="string">    pos_ratio : float, default is 0.5</span></span><br><span class="line"><span class="string">        ``pos_ratio`` defines how many positive samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, short=<span class="number">600</span>, max_size=<span class="number">1000</span>, net=None, mean=<span class="params">(<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 std=<span class="params">(<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>)</span>, box_norm=<span class="params">(<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 num_sample=<span class="number">256</span>, pos_iou_thresh=<span class="number">0.7</span>, neg_iou_thresh=<span class="number">0.3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 pos_ratio=<span class="number">0.5</span>, **kwargs)</span>:</span></span><br><span class="line">        self._short = short</span><br><span class="line">        self._max_size = max_size</span><br><span class="line">        self._mean = mean</span><br><span class="line">        self._std = std</span><br><span class="line">        self._anchors = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> net <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># use fake data to generate fixed anchors for target generation</span></span><br><span class="line">        ashape = <span class="number">128</span></span><br><span class="line">        <span class="comment"># in case network has reset_ctx to gpu</span></span><br><span class="line">        <span class="comment"># 将rpn网络进行深拷贝，所以之后rpn网络有变化，这里的anchor_generator也会变</span></span><br><span class="line">        anchor_generator = copy.deepcopy(net.rpn.anchor_generator)</span><br><span class="line">        anchor_generator.collect_params().reset_ctx(<span class="keyword">None</span>)</span><br><span class="line">        anchors = anchor_generator(</span><br><span class="line">            mx.nd.zeros((<span class="number">1</span>, <span class="number">3</span>, ashape, ashape))).reshape((<span class="number">1</span>, <span class="number">1</span>, ashape, ashape, <span class="number">-1</span>))</span><br><span class="line">        self._anchors = anchors</span><br><span class="line">        <span class="comment"># record feature extractor for infer_shape</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(net, <span class="string">'features'</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Cannot find features in network, it is a Faster-RCNN network?"</span>)</span><br><span class="line">        self._feat_sym = net.features(mx.sym.var(name=<span class="string">'data'</span>))</span><br><span class="line">        <span class="keyword">from</span> ....model_zoo.rpn.rpn_target <span class="keyword">import</span> RPNTargetGenerator</span><br><span class="line">        self._target_generator = RPNTargetGenerator(</span><br><span class="line">            num_sample=num_sample, pos_iou_thresh=pos_iou_thresh,</span><br><span class="line">            neg_iou_thresh=neg_iou_thresh, pos_ratio=pos_ratio,</span><br><span class="line">            stds=box_norm, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, src, label)</span>:</span></span><br><span class="line">        <span class="string">"""Apply transform to training image/label."""</span></span><br><span class="line">        <span class="comment"># resize shorter side but keep in max_size</span></span><br><span class="line">        <span class="comment"># 假如src.shape=(w*h*c)=(375*500*3) label shape=(10*6)</span></span><br><span class="line">        h, w, _ = src.shape</span><br><span class="line">        <span class="comment"># imag shape=(600*800*3)</span></span><br><span class="line">        img = timage.resize_short_within(src, self._short, self._max_size)</span><br><span class="line">        <span class="comment"># bbox shape=(10*6)，做相同比例缩放或拉伸</span></span><br><span class="line">        bbox = tbbox.resize(label, (w, h), (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># random horizontal flip</span></span><br><span class="line">        <span class="comment"># h=600 w=800 </span></span><br><span class="line">        h, w, _ = img.shape</span><br><span class="line">        <span class="comment"># 随机左右翻转，flips记录翻转类型，上下翻转，左右翻转</span></span><br><span class="line">        img, flips = timage.random_flip(img, px=<span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># bbox也相应进行翻转</span></span><br><span class="line">        bbox = tbbox.flip(bbox, (w, h), flip_x=flips[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># to tensor</span></span><br><span class="line">        <span class="comment"># img shape变为3*600*800，并且在值在0-1之间，但并没有归一化</span></span><br><span class="line">        img = mx.nd.image.to_tensor(img)</span><br><span class="line">        <span class="comment"># 归一化操作</span></span><br><span class="line">        img = mx.nd.image.normalize(img, mean=self._mean, std=self._std)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._anchors <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> img, bbox.astype(img.dtype)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># generate RPN target so cpu workers can help reduce the workload</span></span><br><span class="line">        <span class="comment"># feat_h, feat_w = (img.shape[1] // self._stride, img.shape[2] // self._stride)</span></span><br><span class="line">        <span class="comment"># 推断特征图尺寸 600//16=38, 800//16=50 oshape=(1, 1024, 38, 50)</span></span><br><span class="line">        oshape = self._feat_sym.infer_shape(data=(<span class="number">1</span>, <span class="number">3</span>, img.shape[<span class="number">1</span>], img.shape[<span class="number">2</span>]))[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 从预生成的anchors取出对应尺寸(38*50)的anchor，然后resize，ahchor shape=(28500*4), 28500=38*50*15</span></span><br><span class="line">        anchor = self._anchors[:, :, :oshape[<span class="number">2</span>], :oshape[<span class="number">3</span>], :].reshape((<span class="number">-1</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment"># 得到bbox的坐标，gt_bboxes shape=(1*10*4)</span></span><br><span class="line">        gt_bboxes = mx.nd.array(bbox[np.newaxis, :, :<span class="number">4</span>])</span><br><span class="line">        <span class="comment"># box_target得到正样本box跟gt_box之间要学习的平移和缩放距离</span></span><br><span class="line">        <span class="comment"># box_mask得到box_target对应的mask</span></span><br><span class="line">        <span class="comment"># cls_target得到哪些是正样本，哪些是负样本，哪些需要忽略</span></span><br><span class="line">        cls_target, box_target, box_mask = self._target_generator(</span><br><span class="line">            gt_bboxes, anchor, img.shape[<span class="number">2</span>], img.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># img：reshape、normalzie之后的图像</span></span><br><span class="line">        <span class="comment"># bbox：reshape之后的gt_box</span></span><br><span class="line">        <span class="comment"># cls_target[0]：哪些是正样本，哪些是负样本，哪些需要忽略，跟之前一样，只是降了一个维度</span></span><br><span class="line">        <span class="comment"># box_target[0]：正样本box跟gt_box之间要学习的平移和缩放距离，跟之前一样，只是降了一个维度</span></span><br><span class="line">        <span class="comment"># box_mask[0]：box_target对应的mask，跟之前一样，只是降了一个维度</span></span><br><span class="line">        <span class="keyword">return</span> img, bbox.astype(img.dtype), cls_target[<span class="number">0</span>], box_target[<span class="number">0</span>], box_mask[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>iou大于等于0.7的正样本，大于0，小于等于0.3之间的负样本，iou为0的忽略，正负样本一种256个，尽量均匀<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPNTargetGenerator</span><span class="params">(gluon.Block)</span>:</span></span><br><span class="line">    <span class="string">"""RPN target generator network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    num_sample : int, default is 256</span></span><br><span class="line"><span class="string">        Number of samples for RPN targets.</span></span><br><span class="line"><span class="string">    pos_iou_thresh : float, default is 0.7</span></span><br><span class="line"><span class="string">        Anchor with IOU larger than ``pos_iou_thresh`` is regarded as positive samples.</span></span><br><span class="line"><span class="string">    neg_iou_thresh : float, default is 0.3</span></span><br><span class="line"><span class="string">        Anchor with IOU smaller than ``neg_iou_thresh`` is regarded as negative samples.</span></span><br><span class="line"><span class="string">        Anchors with IOU in between ``pos_iou_thresh`` and ``neg_iou_thresh`` are</span></span><br><span class="line"><span class="string">        ignored.</span></span><br><span class="line"><span class="string">    pos_ratio : float, default is 0.5</span></span><br><span class="line"><span class="string">        ``pos_ratio`` defines how many positive samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled.</span></span><br><span class="line"><span class="string">    stds : array-like of size 4, default is (1., 1., 1., 1.)</span></span><br><span class="line"><span class="string">        Std value to be divided from encoded regression targets.</span></span><br><span class="line"><span class="string">    allowed_border : int or float, default is 0</span></span><br><span class="line"><span class="string">        The allowed distance of anchors which are off the image border. This is used to clip out of</span></span><br><span class="line"><span class="string">        border anchors. You can set it to very large value to keep all anchors.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sample=<span class="number">256</span>, pos_iou_thresh=<span class="number">0.7</span>, neg_iou_thresh=<span class="number">0.3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 pos_ratio=<span class="number">0.5</span>, stds=<span class="params">(<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)</span>, allowed_border=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super(RPNTargetGenerator, self).__init__()</span><br><span class="line">        self._num_sample = num_sample</span><br><span class="line">        self._pos_iou_thresh = pos_iou_thresh</span><br><span class="line">        self._neg_iou_thresh = neg_iou_thresh</span><br><span class="line">        self._pos_ratio = pos_ratio</span><br><span class="line">        self._allowed_border = allowed_border</span><br><span class="line">        self._bbox_split = BBoxSplit(axis=<span class="number">-1</span>)</span><br><span class="line">        self._matcher = CompositeMatcher([BipartiteMatcher(), MaximumMatcher(pos_iou_thresh)])</span><br><span class="line">        self._sampler = QuotaSampler(num_sample, pos_iou_thresh, neg_iou_thresh, <span class="number">0.</span>, pos_ratio)</span><br><span class="line">        self._cls_encoder = SigmoidClassEncoder()</span><br><span class="line">        self._box_encoder = NormalizedBoxCenterEncoder(stds=stds)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, bbox, anchor, width, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Only support batch_size=1 now.</span></span><br><span class="line"><span class="string">        Be careful there's numpy operations inside</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        F = mx.nd</span><br><span class="line">        <span class="keyword">with</span> autograd.pause():</span><br><span class="line">            <span class="comment"># anchor with shape (N, 4)</span></span><br><span class="line">            <span class="comment"># 假如anchor的shape为(N, 4)，这里提取第二个维度的值，所以得到的shape为(N, 1)</span></span><br><span class="line">            a_xmin, a_ymin, a_xmax, a_ymax = self._bbox_split(anchor)</span><br><span class="line">            <span class="comment"># invalid anchor mask with shape (N, 1)</span></span><br><span class="line">            <span class="comment"># imask中保存无效的anchor的信息，即那些超出像素的。对应位置为true</span></span><br><span class="line">            imask = (</span><br><span class="line">                (a_xmin &gt;= -self._allowed_border) *</span><br><span class="line">                (a_ymin &gt;= -self._allowed_border) *</span><br><span class="line">                (a_xmax &lt;= (width + self._allowed_border)) *</span><br><span class="line">                (a_ymax &lt;= (height + self._allowed_border))) &lt;= <span class="number">0</span></span><br><span class="line">            <span class="comment"># imask中保存无效的anchor的位置信息，例如第六个和二十个anchor无效，则imask为[6, 20]</span></span><br><span class="line">            imask = mx.nd.array(np.where(imask.asnumpy() &gt; <span class="number">0</span>)[<span class="number">0</span>], ctx=anchor.context)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># calculate ious between (N, 4) anchors and (M, 4) bbox ground-truths</span></span><br><span class="line">            <span class="comment"># ious is (N, M)</span></span><br><span class="line">            <span class="comment"># 计算anchor与每个bbox的iou，加入anchor为N*4，bbox为1*M*4，则iou为1*N*M</span></span><br><span class="line">            ious = F.contrib.box_iou(anchor, bbox, format=<span class="string">'corner'</span>).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">            <span class="comment"># 将无效的anchor对应的ious填充为0</span></span><br><span class="line">            ious[:, imask, :] = <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 得到每个bbox与哪个gt_box匹配，背景为-1，阈值0.7，例如[[-1, -1, 0, -1, 2, 1 ]]</span></span><br><span class="line">            matches = self._matcher(ious)</span><br><span class="line">            <span class="comment"># samples得到哪些是正样本，哪些是负样本，以及哪些是需要忽略的样本，正负样本加起来一共256个</span></span><br><span class="line">            samples = self._sampler(matches, ious)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># training targets for RPN</span></span><br><span class="line">            <span class="comment"># samples中-1：负样本，0：忽略，1正样本，而cls_target中，-1：忽略，0：负样本，1：正样本</span></span><br><span class="line">            cls_target, _ = self._cls_encoder(samples)</span><br><span class="line">            <span class="comment"># box_target得到正样本box跟gt_box之间要学习的平移和缩放距离</span></span><br><span class="line">            <span class="comment"># box_mask得到box_target对应的mask</span></span><br><span class="line">            <span class="comment"># cls_target得到哪些是正样本，哪些是负样本，哪些需要忽略</span></span><br><span class="line">            box_target, box_mask = self._box_encoder(</span><br><span class="line">                samples, matches, anchor.expand_dims(axis=<span class="number">0</span>), bbox)</span><br><span class="line">        <span class="keyword">return</span> cls_target, box_target, box_mask</span><br></pre></td></tr></table></figure></p>
<p>假设x shape=(1<em>28500</em>7)<br>match[0] shape=(1*28500)，表示哪个box与哪个gt_box的的iou最高，里面只有7个值&gt;=0，其他都是-1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BipartiteMatcher</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">"""A Matcher implementing bipartite matching strategy.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    threshold : float</span></span><br><span class="line"><span class="string">        Threshold used to ignore invalid paddings</span></span><br><span class="line"><span class="string">    is_ascend : bool</span></span><br><span class="line"><span class="string">        Whether sort matching order in ascending order. Default is False.</span></span><br><span class="line"><span class="string">    eps : float</span></span><br><span class="line"><span class="string">        Epsilon for floating number comparison</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threshold=<span class="number">1e-12</span>, is_ascend=False, eps=<span class="number">1e-12</span>)</span>:</span></span><br><span class="line">        super(BipartiteMatcher, self).__init__()</span><br><span class="line">        self._threshold = threshold</span><br><span class="line">        self._is_ascend = is_ascend</span><br><span class="line">        self._eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, x)</span>:</span></span><br><span class="line">        <span class="string">"""BipartiteMatching</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        x : NDArray or Symbol</span></span><br><span class="line"><span class="string">            IOU overlaps with shape (N, M), batching is supported.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># x是每个anchor与gt_box的iou，N个样本，M个gt_box，则x shape=(1*N*M)</span></span><br><span class="line">        <span class="comment"># match[0]表示哪个anchor与label最匹配</span></span><br><span class="line">        <span class="comment"># 例如N为4时，M为2，如果返回[[1, -1, 0, -1]]，表示第1个box与gt_box[1]最匹配，第3个anchor与gt_box[0]最匹配，第二个和第三个box没有匹配的gt_box</span></span><br><span class="line">        match = F.contrib.bipartite_matching(x, threshold=self._threshold,</span><br><span class="line">                                             is_ascend=self._is_ascend)</span><br><span class="line">        <span class="comment"># make sure if iou(a, y) == iou(b, y), then b should also be a good match</span></span><br><span class="line">        <span class="comment"># otherwise positive/negative samples are confusing</span></span><br><span class="line">        <span class="comment"># potential argmax and max</span></span><br><span class="line">        <span class="comment"># pargmax得到每个archor中哪个gt_box的分数最高，保存的是gt_box的索引</span></span><br><span class="line">        pargmax = x.argmax(axis=<span class="number">-1</span>, keepdims=<span class="keyword">True</span>)  <span class="comment"># (B, num_anchor, 1)</span></span><br><span class="line">        <span class="comment"># maxs得到各个gt_box最高的得分，shape (B, 1, num_gt)</span></span><br><span class="line">        maxs = x.max(axis=<span class="number">-2</span>, keepdims=<span class="keyword">True</span>)  <span class="comment"># (B, 1, num_gt)</span></span><br><span class="line">        <span class="comment"># 按照pargmax中保存的索引得到每个anchor中最高的分数</span></span><br><span class="line">        pmax = F.pick(x, pargmax, axis=<span class="number">-1</span>, keepdims=<span class="keyword">True</span>)   <span class="comment"># (B, num_anchor, 1)</span></span><br><span class="line">        <span class="comment"># 特定的broadcast操作，例如pmax shape=(1*28500*1)，变为(1*28500*2)，同时第三个维度中的数组值跟maxs数组相应的位置进行比较，小于maxs则为0，大于等于则为1</span></span><br><span class="line">        <span class="comment"># 然后pick操作相当于得到每个gt_box最高分对应的box，相应box的位置赋值为1，其他的赋值为0</span></span><br><span class="line">        <span class="comment"># 例如得到[[[0], [0], [0], [1], [0], [1]]]</span></span><br><span class="line">        mask = F.broadcast_greater_equal(pmax + self._eps, maxs)  <span class="comment"># (B, num_anchor, num_gt)</span></span><br><span class="line">        mask = F.pick(mask, pargmax, axis=<span class="number">-1</span>, keepdims=<span class="keyword">True</span>)  <span class="comment"># (B, num_anchor, 1)</span></span><br><span class="line">        <span class="comment"># 得到mask的中值为1的box对应哪个gt_box，对应mask中值为0的box位置都赋为-1</span></span><br><span class="line">        <span class="comment"># 例如得到[[[-1], [-1], [-1], [0], [-1], [1]]]</span></span><br><span class="line">        new_match = F.where(mask &gt; <span class="number">0</span>, pargmax, F.ones_like(pargmax) * <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 按照match[0]，综合match[0]和new_match，将match[0]中为负的值，用new_match中相应位置的值代替</span></span><br><span class="line">        result = F.where(match[<span class="number">0</span>] &lt; <span class="number">0</span>, new_match.squeeze(axis=<span class="number">-1</span>), match[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCNNTargetGenerator</span><span class="params">(gluon.Block)</span>:</span></span><br><span class="line">    <span class="string">"""RCNN target encoder to generate matching target and regression target values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    num_class : int</span></span><br><span class="line"><span class="string">        Number of total number of positive classes.</span></span><br><span class="line"><span class="string">    means : iterable of float, default is (0., 0., 0., 0.)</span></span><br><span class="line"><span class="string">        Mean values to be subtracted from regression targets.</span></span><br><span class="line"><span class="string">    stds : iterable of float, default is (.1, .1, .2, .2)</span></span><br><span class="line"><span class="string">        Standard deviations to be divided from regression targets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_class, means=<span class="params">(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)</span>, stds=<span class="params">(<span class="number">.1</span>, <span class="number">.1</span>, <span class="number">.2</span>, <span class="number">.2</span>)</span>)</span>:</span></span><br><span class="line">        super(RCNNTargetGenerator, self).__init__()</span><br><span class="line">        self._cls_encoder = MultiClassEncoder()</span><br><span class="line">        self._box_encoder = NormalizedPerClassBoxCenterEncoder(</span><br><span class="line">            num_class=num_class, means=means, stds=stds)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#pylint: disable=arguments-differ</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, roi, samples, matches, gt_label, gt_box)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Only support batch_size=1 now.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> autograd.pause():</span><br><span class="line">            <span class="comment"># 得到每个box属于哪个类，负样本为0，例如shape=1*128</span></span><br><span class="line">            cls_target = self._cls_encoder(samples, matches, gt_label)</span><br><span class="line">            <span class="comment"># box_target得到每个box的偏移和缩放，shape=20*1*128*4</span></span><br><span class="line">            <span class="comment"># box_mask得到每各box的是否属于这个类，shape=20*1*128*4</span></span><br><span class="line">            box_target, box_mask = self._box_encoder(</span><br><span class="line">                samples, matches, roi, gt_label, gt_box)</span><br><span class="line">            <span class="comment"># modify shapes to match predictions</span></span><br><span class="line">            <span class="comment"># 去掉一个维度，shape=(128,)</span></span><br><span class="line">            cls_target = cls_target[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># shape变为128*20*4</span></span><br><span class="line">            box_target = box_target.transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>))[<span class="number">0</span>]</span><br><span class="line">            box_mask = box_mask.transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> cls_target, box_target, box_mask</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalizedPerClassBoxCenterEncoder</span><span class="params">(gluon.Block)</span>:</span></span><br><span class="line">    <span class="string">"""Encode bounding boxes training target with normalized center offsets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Input bounding boxes are using corner type: `x_&#123;min&#125;, y_&#123;min&#125;, x_&#123;max&#125;, y_&#123;max&#125;`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    stds : array-like of size 4</span></span><br><span class="line"><span class="string">        Std value to be divided from encoded values, default is (0.1, 0.1, 0.2, 0.2).</span></span><br><span class="line"><span class="string">    means : array-like of size 4</span></span><br><span class="line"><span class="string">        Mean value to be subtracted from encoded values, default is (0., 0., 0., 0.).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_class, stds=<span class="params">(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>)</span>, means=<span class="params">(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)</span>)</span>:</span></span><br><span class="line">        super(NormalizedPerClassBoxCenterEncoder, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> len(stds) == <span class="number">4</span>, <span class="string">"Box Encoder requires 4 std values."</span></span><br><span class="line">        <span class="keyword">assert</span> num_class &gt; <span class="number">0</span>, <span class="string">"Number of classes must be positive"</span></span><br><span class="line">        self._num_class = num_class</span><br><span class="line">        self._stds = stds</span><br><span class="line">        self._means = means</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.corner_to_center = BBoxCornerToCenter(split=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, samples, matches, anchors, labels, refs)</span>:</span></span><br><span class="line">        <span class="string">"""Encode BBox One entry per category"""</span></span><br><span class="line">        F = nd</span><br><span class="line">        <span class="comment"># 根据matches得到每个box对应的gt_box坐标，例如shape=(1*128*4)</span></span><br><span class="line">        ref_boxes = F.repeat(refs.reshape((<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">4</span>)), axis=<span class="number">1</span>, repeats=matches.shape[<span class="number">1</span>])</span><br><span class="line">        ref_boxes = F.split(ref_boxes, axis=<span class="number">-1</span>, num_outputs=<span class="number">4</span>, squeeze_axis=<span class="keyword">True</span>)</span><br><span class="line">        ref_boxes = F.concat(*[F.pick(ref_boxes[i], matches, axis=<span class="number">2</span>).reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)) \</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)], dim=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 得到每个box对应的类label</span></span><br><span class="line">        ref_labels = F.repeat(labels.reshape((<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)), axis=<span class="number">1</span>, repeats=matches.shape[<span class="number">1</span>])</span><br><span class="line">        ref_labels = F.pick(ref_labels, matches, axis=<span class="number">2</span>).reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 对角坐标转为中心坐标</span></span><br><span class="line">        g = self.corner_to_center(ref_boxes)</span><br><span class="line">        a = self.corner_to_center(anchors)</span><br><span class="line">        <span class="comment"># 计算偏移与缩放</span></span><br><span class="line">        t0 = ((g[<span class="number">0</span>] - a[<span class="number">0</span>]) / a[<span class="number">2</span>] - self._means[<span class="number">0</span>]) / self._stds[<span class="number">0</span>]</span><br><span class="line">        t1 = ((g[<span class="number">1</span>] - a[<span class="number">1</span>]) / a[<span class="number">3</span>] - self._means[<span class="number">1</span>]) / self._stds[<span class="number">1</span>]</span><br><span class="line">        t2 = (F.log(g[<span class="number">2</span>] / a[<span class="number">2</span>]) - self._means[<span class="number">2</span>]) / self._stds[<span class="number">2</span>]</span><br><span class="line">        t3 = (F.log(g[<span class="number">3</span>] / a[<span class="number">3</span>]) - self._means[<span class="number">3</span>]) / self._stds[<span class="number">3</span>]</span><br><span class="line">        codecs = F.concat(t0, t1, t2, t3, dim=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 假设samples shape=(1*128*1)，赋值四次后得到shape=(1*128*4)，然后找出大于0.5的值，赋值为true，其他false</span></span><br><span class="line">        temp = F.tile(samples.reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)), reps=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)) &gt; <span class="number">0.5</span></span><br><span class="line">        <span class="comment"># 将正样本的位置填入t0 t1 t2 t3，其他的位置都是0</span></span><br><span class="line">        targets = F.where(temp, codecs, F.zeros_like(codecs))</span><br><span class="line">        <span class="comment"># 将正样本的位置填入1，其他的都是0</span></span><br><span class="line">        masks = F.where(temp, F.ones_like(temp), F.zeros_like(temp))</span><br><span class="line">        out_targets = []</span><br><span class="line">        out_masks = []</span><br><span class="line">        <span class="comment"># out_targets是一个list，有num_class个元素，每个元素是之前targets的一份赋值</span></span><br><span class="line">        <span class="comment"># out_masks是一个list，有num_class个元素，第i个元素是一个1*128*4的ndarray，4个维度相同，非0表示这个box是第i类的box</span></span><br><span class="line">        <span class="keyword">for</span> cid <span class="keyword">in</span> range(self._num_class):</span><br><span class="line">            same_cid = ref_labels == cid</span><br><span class="line">            <span class="comment"># keep orig targets</span></span><br><span class="line">            out_targets.append(targets)</span><br><span class="line">            <span class="comment"># but mask out the one not belong to this class</span></span><br><span class="line">            out_masks.append(masks * same_cid.repeat(axis=<span class="number">-1</span>, repeats=<span class="number">4</span>))</span><br><span class="line">        <span class="comment"># 假如有20个类，128个box，则shape=20*1*128*4，其中每一维都相同，都保存了所有正样本的平移和缩放，负样本为0</span></span><br><span class="line">        all_targets = F.stack(*out_targets, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 假如有20个类，128个box，则shape=20*1*128*4，其中mask为1的位置表示相应的box属于第i类</span></span><br><span class="line">        all_masks = F.stack(*out_masks, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> all_targets, all_masks</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiClassEncoder</span><span class="params">(gluon.HybridBlock)</span>:</span></span><br><span class="line">    <span class="string">"""Encode classification training target given matching results.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This encoder will assign training target of matched bounding boxes to</span></span><br><span class="line"><span class="string">    ground-truth label + 1 and negative samples with label 0.</span></span><br><span class="line"><span class="string">    Ignored samples will be assigned with `ignore_label`, whose default is -1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    ignore_label : float</span></span><br><span class="line"><span class="string">        Assigned to un-matched samples, they are neither positive or negative during</span></span><br><span class="line"><span class="string">        training, and should be excluded in loss function. Default is -1.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ignore_label=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        super(MultiClassEncoder, self).__init__()</span><br><span class="line">        self._ignore_label = ignore_label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, samples, matches, refs)</span>:</span></span><br><span class="line">        <span class="comment"># 假设有两个gt_box，refs shape=1*2*1，有128个预测box，shape=1*128</span></span><br><span class="line">        <span class="comment"># 这一步赋值refs，使得shape=1*128*2</span></span><br><span class="line">        refs = F.repeat(refs.reshape((<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)), axis=<span class="number">1</span>, repeats=matches.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 按照matches得出对应的box属于哪一类，加1是因为背景为0，shape=1*128</span></span><br><span class="line">        target_ids = F.pick(refs, matches, axis=<span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># targets得到每个正例box属于哪一类，负样本为-1</span></span><br><span class="line">        targets = F.where(samples &gt; <span class="number">0.5</span>, target_ids, nd.ones_like(target_ids) * self._ignore_label)</span><br><span class="line">        <span class="comment"># 负样本变为0，shape=1*128</span></span><br><span class="line">        targets = F.where(samples &lt; <span class="number">-0.5</span>, nd.zeros_like(targets), targets)</span><br><span class="line">        <span class="comment"># targets得出每个box属于哪一类</span></span><br><span class="line">        <span class="keyword">return</span> targets</span><br></pre></td></tr></table></figure>
<h2 id="采样正样本和负样本"><a href="#采样正样本和负样本" class="headerlink" title="采样正样本和负样本"></a>采样正样本和负样本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotaSampler</span><span class="params">(gluon.Block)</span>:</span></span><br><span class="line">    <span class="string">"""Sampler that handles limited quota for positive and negative samples.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    num_sample : int, default is 128</span></span><br><span class="line"><span class="string">        Number of samples for RCNN targets.</span></span><br><span class="line"><span class="string">    pos_iou_thresh : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU larger than ``pos_iou_thresh`` is regarded as positive samples.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_high : float, default is 0.5</span></span><br><span class="line"><span class="string">        Proposal whose IOU smaller than ``neg_iou_thresh_high``</span></span><br><span class="line"><span class="string">        and larger than ``neg_iou_thresh_low``</span></span><br><span class="line"><span class="string">        is regarded as negative samples.</span></span><br><span class="line"><span class="string">        Proposals with IOU in between ``pos_iou_thresh`` and ``neg_iou_thresh`` are</span></span><br><span class="line"><span class="string">        ignored.</span></span><br><span class="line"><span class="string">    neg_iou_thresh_low : float, default is 0.0</span></span><br><span class="line"><span class="string">        See ``neg_iou_thresh_high``.</span></span><br><span class="line"><span class="string">    pos_ratio : float, default is 0.25</span></span><br><span class="line"><span class="string">        ``pos_ratio`` defines how many positive samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled.</span></span><br><span class="line"><span class="string">    neg_ratio : float or None</span></span><br><span class="line"><span class="string">        ``neg_ratio`` defines how many negative samples (``pos_ratio * num_sample``) is</span></span><br><span class="line"><span class="string">        to be sampled. If ``None`` is provided, it equals to ``1 - pos_ratio``.</span></span><br><span class="line"><span class="string">    fill_negative : bool</span></span><br><span class="line"><span class="string">        If ``True``, negative samples will fill the gap caused by insufficient positive samples.</span></span><br><span class="line"><span class="string">        For example, if ``num_sample`` is 100, ``pos_ratio`` and ``neg_ratio`` are both ``0.5``.</span></span><br><span class="line"><span class="string">        Available positive sample and negative samples are 10 and 10000, which are typical values.</span></span><br><span class="line"><span class="string">        Now, the output positive samples is 10(intact), since it's smaller than ``50(100 * 0.5)``,</span></span><br><span class="line"><span class="string">        the negative samples will fill the rest ``40`` slots.</span></span><br><span class="line"><span class="string">        If ``fill_negative == False``, the ``40`` slots is filled with ``-1(ignore)``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sample, pos_thresh, neg_thresh_high, neg_thresh_low=-np.inf,</span></span></span><br><span class="line"><span class="function"><span class="params">                 pos_ratio=<span class="number">0.5</span>, neg_ratio=None, fill_negative=True)</span>:</span></span><br><span class="line">        super(QuotaSampler, self).__init__()</span><br><span class="line">        self._fill_negative = fill_negative</span><br><span class="line">        self._num_sample = num_sample</span><br><span class="line">        <span class="keyword">if</span> neg_ratio <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self._neg_ratio = <span class="number">1.</span> - pos_ratio</span><br><span class="line">        self._pos_ratio = pos_ratio</span><br><span class="line">        <span class="keyword">assert</span> (self._neg_ratio + self._pos_ratio) &lt;= <span class="number">1.0</span>, (</span><br><span class="line">            <span class="string">"Positive and negative ratio &#123;&#125; exceed 1"</span>.format(self._neg_ratio + self._pos_ratio))</span><br><span class="line">        self._pos_thresh = min(<span class="number">1.</span>, max(<span class="number">0.</span>, pos_thresh))</span><br><span class="line">        self._neg_thresh_high = min(<span class="number">1.</span>, max(<span class="number">0.</span>, neg_thresh_high))</span><br><span class="line">        self._neg_thresh_low = neg_thresh_low</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, matches, ious)</span>:</span></span><br><span class="line">        <span class="string">"""Quota Sampler</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Parameters:</span></span><br><span class="line"><span class="string">        ----------</span></span><br><span class="line"><span class="string">        matches : NDArray or Symbol</span></span><br><span class="line"><span class="string">            Matching results, postive number for postive matching, -1 for not matched.</span></span><br><span class="line"><span class="string">        ious : NDArray or Symbol</span></span><br><span class="line"><span class="string">            IOU overlaps with shape (N, M), batching is supported.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        --------</span></span><br><span class="line"><span class="string">        NDArray or Symbol</span></span><br><span class="line"><span class="string">            Sampling results with same shape as ``matches``.</span></span><br><span class="line"><span class="string">            1 for positive, -1 for negative, 0 for ignore.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 假设matches shape=(1*28500)， ious shape=(1)</span></span><br><span class="line">        F = mx.nd</span><br><span class="line">        <span class="comment"># 最大正样本数量</span></span><br><span class="line">        max_pos = int(round(self._pos_ratio * self._num_sample))</span><br><span class="line">        <span class="comment"># 最大负样本数量</span></span><br><span class="line">        max_neg = int(self._neg_ratio * self._num_sample)</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(matches.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="comment"># init with 0s, which are ignored</span></span><br><span class="line">            <span class="comment"># 初始化为0 result shape=(28500, )</span></span><br><span class="line">            result = F.zeros_like(matches[<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># negative samples with label -1</span></span><br><span class="line">            <span class="comment"># 得到每个box最大的分数</span></span><br><span class="line">            <span class="comment"># 例如 x=[[[1, 2, 3], [2, 8, 1], [1, 2, 5]]]，则返回的是[3, 8, 5]</span></span><br><span class="line">            ious_max = ious.max(axis=<span class="number">-1</span>)[i]</span><br><span class="line">            <span class="comment"># 得到ious_max中介于self._neg_thresh_low和self._neg_thresh_high之间的位置，默认0和0.3</span></span><br><span class="line">            neg_mask = ious_max &lt; self._neg_thresh_high</span><br><span class="line">            neg_mask = neg_mask * (ious_max &gt;= self._neg_thresh_low)</span><br><span class="line">            <span class="comment"># 按照neg_mask，将result中对应位置值为-1，这些位置表示负样本</span></span><br><span class="line">            result = F.where(neg_mask, F.ones_like(result) * <span class="number">-1</span>, result)</span><br><span class="line">            <span class="comment"># positive samples</span></span><br><span class="line">            <span class="comment"># 按照matches和ious_max，将正样本的位置值为1</span></span><br><span class="line">            result = F.where(matches[i] &gt;= <span class="number">0</span>, F.ones_like(result), result)</span><br><span class="line">            result = F.where(ious_max &gt;= self._pos_thresh, F.ones_like(result), result)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># re-balance if number of postive or negative exceed limits</span></span><br><span class="line">            result = result.asnumpy()</span><br><span class="line">            <span class="comment"># 计算正样本的数量</span></span><br><span class="line">            num_pos = int((result &gt; <span class="number">0</span>).sum())</span><br><span class="line">            <span class="comment"># 如果正样本的数量大于最大正样本数，随机将num_pos-max_pos个box的值置为0，即ignore了</span></span><br><span class="line">            <span class="keyword">if</span> num_pos &gt; max_pos:</span><br><span class="line">                disable_indices = np.random.choice(</span><br><span class="line">                    np.where(result &gt; <span class="number">0</span>)[<span class="number">0</span>], size=(num_pos - max_pos), replace=<span class="keyword">False</span>)</span><br><span class="line">                result[disable_indices] = <span class="number">0</span>   <span class="comment"># use 0 to ignore</span></span><br><span class="line">            <span class="comment"># 获得负样本数量</span></span><br><span class="line">            num_neg = int((result &lt; <span class="number">0</span>).sum())</span><br><span class="line">            <span class="keyword">if</span> self._fill_negative:</span><br><span class="line">                <span class="comment"># if pos_sample is less than quota, we can have negative samples filling the gap</span></span><br><span class="line">                <span class="comment"># 如果正样本小于额给定值，那就用负样本来填补</span></span><br><span class="line">                <span class="comment"># 例如，256个样本，128正128负，如果只有50个正的，那负样本就为201个</span></span><br><span class="line">                max_neg = max(self._num_sample - min(num_pos, max_pos), max_neg)</span><br><span class="line">            <span class="keyword">if</span> num_neg &gt; max_neg:</span><br><span class="line">                <span class="comment"># 随机选取num_neg-max_neg个负样本忽略，就剩下了max_neg个负样本</span></span><br><span class="line">                disable_indices = np.random.choice(</span><br><span class="line">                    np.where(result &lt; <span class="number">0</span>)[<span class="number">0</span>], size=(num_neg - max_neg), replace=<span class="keyword">False</span>)</span><br><span class="line">                result[disable_indices] = <span class="number">0</span></span><br><span class="line">            results.append(mx.nd.array(result))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># results中包含了</span></span><br><span class="line">        <span class="keyword">return</span> mx.nd.stack(*results, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalizedBoxCenterEncoder</span><span class="params">(gluon.Block)</span>:</span></span><br><span class="line">    <span class="string">"""Encode bounding boxes training target with normalized center offsets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Input bounding boxes are using corner type: `x_&#123;min&#125;, y_&#123;min&#125;, x_&#123;max&#125;, y_&#123;max&#125;`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    stds : array-like of size 4</span></span><br><span class="line"><span class="string">        Std value to be divided from encoded values, default is (0.1, 0.1, 0.2, 0.2).</span></span><br><span class="line"><span class="string">    means : array-like of size 4</span></span><br><span class="line"><span class="string">        Mean value to be subtracted from encoded values, default is (0., 0., 0., 0.).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, stds=<span class="params">(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>)</span>, means=<span class="params">(<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>)</span>)</span>:</span></span><br><span class="line">        super(NormalizedBoxCenterEncoder, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> len(stds) == <span class="number">4</span>, <span class="string">"Box Encoder requires 4 std values."</span></span><br><span class="line">        self._stds = stds</span><br><span class="line">        self._means = means</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.corner_to_center = BBoxCornerToCenter(split=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, samples, matches, anchors, refs)</span>:</span></span><br><span class="line">        <span class="string">"""Forward"""</span></span><br><span class="line">        F = nd</span><br><span class="line">        <span class="comment"># TODO(zhreshold): batch_pick, take multiple elements?</span></span><br><span class="line">        <span class="comment"># 假如refs shape=(1*5*4)，是gt_box</span></span><br><span class="line">        <span class="comment"># 将gt_box重复matches的数量次，假如matches shape=(1*32490)，则ref_boxes shape=(1*32490*5*4)</span></span><br><span class="line">        ref_boxes = nd.repeat(refs.reshape((<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">4</span>)), axis=<span class="number">1</span>, repeats=matches.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># ref_boxes分为4分，每份shape=(1*32490*5)</span></span><br><span class="line">        ref_boxes = nd.split(ref_boxes, axis=<span class="number">-1</span>, num_outputs=<span class="number">4</span>, squeeze_axis=<span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># 根据matches得到每个box应对应的gt_box坐标，shape=(1*32490*4)</span></span><br><span class="line">        ref_boxes = nd.concat(*[F.pick(ref_boxes[i], matches, axis=<span class="number">2</span>).reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)) \</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)], dim=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 将对角坐标转为中心坐标</span></span><br><span class="line">        g = self.corner_to_center(ref_boxes)</span><br><span class="line">        a = self.corner_to_center(anchors)</span><br><span class="line">        <span class="comment"># 得出每个box对应的平移和缩放大小</span></span><br><span class="line">        t0 = ((g[<span class="number">0</span>] - a[<span class="number">0</span>]) / a[<span class="number">2</span>] - self._means[<span class="number">0</span>]) / self._stds[<span class="number">0</span>]</span><br><span class="line">        t1 = ((g[<span class="number">1</span>] - a[<span class="number">1</span>]) / a[<span class="number">3</span>] - self._means[<span class="number">1</span>]) / self._stds[<span class="number">1</span>]</span><br><span class="line">        t2 = (F.log(g[<span class="number">2</span>] / a[<span class="number">2</span>]) - self._means[<span class="number">2</span>]) / self._stds[<span class="number">2</span>]</span><br><span class="line">        t3 = (F.log(g[<span class="number">3</span>] / a[<span class="number">3</span>]) - self._means[<span class="number">3</span>]) / self._stds[<span class="number">3</span>]</span><br><span class="line">        codecs = F.concat(t0, t1, t2, t3, dim=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 假设samples shape=(1*32490*1)，赋值四次后得到shape=(1*32490*4)，然后找出大于0.5的值，赋值为true，其他false</span></span><br><span class="line">        temp = F.tile(samples.reshape((<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>)), reps=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)) &gt; <span class="number">0.5</span></span><br><span class="line">        <span class="comment"># 将正样本的位置填入t0 t1 t2 t3，其他的位置都是0</span></span><br><span class="line">        targets = F.where(temp, codecs, F.zeros_like(codecs))</span><br><span class="line">        <span class="comment"># 将正样本的位置填入1，其他的都是0</span></span><br><span class="line">        masks = F.where(temp, F.ones_like(temp), F.zeros_like(temp))</span><br><span class="line">        <span class="comment"># 例如，最后的targets=[[[0, 0, 0, 0], [5, 8, 90, 100]]]</span></span><br><span class="line">        <span class="comment"># 最后的mask=[[[0, 0, 0, 0], [1, 1, 1, 1]]]</span></span><br><span class="line">        <span class="keyword">return</span> targets, masks</span><br></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(net, train_data, val_data, eval_metric, args)</span>:</span></span><br><span class="line">    <span class="string">"""Training pipeline"""</span></span><br><span class="line">    net.collect_params().reset_ctx(ctx)</span><br><span class="line">    trainer = gluon.Trainer(</span><br><span class="line">        net.collect_train_params(),  <span class="comment"># fix batchnorm, fix first stage, etc...</span></span><br><span class="line">        <span class="string">'sgd'</span>,</span><br><span class="line">        &#123;<span class="string">'learning_rate'</span>: args.lr,</span><br><span class="line">         <span class="string">'wd'</span>: args.wd,</span><br><span class="line">         <span class="string">'momentum'</span>: args.momentum,</span><br><span class="line">         <span class="string">'clip_gradient'</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lr decay policy</span></span><br><span class="line">    lr_decay = float(args.lr_decay)</span><br><span class="line">    lr_steps = sorted([float(ls) <span class="keyword">for</span> ls <span class="keyword">in</span> args.lr_decay_epoch.split(<span class="string">','</span>) <span class="keyword">if</span> ls.strip()])</span><br><span class="line">    lr_warmup = int(args.lr_warmup)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO(zhreshold) losses?</span></span><br><span class="line">    rpn_cls_loss = mx.gluon.loss.SigmoidBinaryCrossEntropyLoss(from_sigmoid=<span class="keyword">False</span>)</span><br><span class="line">    rpn_box_loss = mx.gluon.loss.HuberLoss(rho=<span class="number">1</span>/<span class="number">9.</span>)  <span class="comment"># == smoothl1</span></span><br><span class="line">    rcnn_cls_loss = mx.gluon.loss.SoftmaxCrossEntropyLoss()</span><br><span class="line">    rcnn_box_loss = mx.gluon.loss.HuberLoss()  <span class="comment"># == smoothl1</span></span><br><span class="line">    metrics = [mx.metric.Loss(<span class="string">'RPN_Conf'</span>),</span><br><span class="line">               mx.metric.Loss(<span class="string">'RPN_SmoothL1'</span>),</span><br><span class="line">               mx.metric.Loss(<span class="string">'RCNN_CrossEntropy'</span>),</span><br><span class="line">               mx.metric.Loss(<span class="string">'RCNN_SmoothL1'</span>),]</span><br><span class="line"></span><br><span class="line">    rpn_acc_metric = RPNAccMetric()</span><br><span class="line">    rpn_bbox_metric = RPNL1LossMetric()</span><br><span class="line">    rcnn_acc_metric = RCNNAccMetric()</span><br><span class="line">    rcnn_bbox_metric = RCNNL1LossMetric()</span><br><span class="line">    metrics2 = [rpn_acc_metric, rpn_bbox_metric, rcnn_acc_metric, rcnn_bbox_metric]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set up logger</span></span><br><span class="line">    logging.basicConfig()</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    log_file_path = args.save_prefix + <span class="string">'_train.log'</span></span><br><span class="line">    log_dir = os.path.dirname(log_file_path)</span><br><span class="line">    <span class="keyword">if</span> log_dir <span class="keyword">and</span> <span class="keyword">not</span> os.path.exists(log_dir):</span><br><span class="line">        os.makedirs(log_dir)</span><br><span class="line">    fh = logging.FileHandler(log_file_path)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    logger.info(args)</span><br><span class="line">    <span class="keyword">if</span> args.verbose:</span><br><span class="line">        logger.info(<span class="string">'Trainable parameters:'</span>)</span><br><span class="line">        logger.info(net.collect_train_params().keys())</span><br><span class="line">    logger.info(<span class="string">'Start training from [Epoch &#123;&#125;]'</span>.format(args.start_epoch))</span><br><span class="line">    best_map = [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(args.start_epoch, args.epochs):</span><br><span class="line">        <span class="keyword">while</span> lr_steps <span class="keyword">and</span> epoch &gt;= lr_steps[<span class="number">0</span>]:</span><br><span class="line">            new_lr = trainer.learning_rate * lr_decay</span><br><span class="line">            lr_steps.pop(<span class="number">0</span>)</span><br><span class="line">            trainer.set_learning_rate(new_lr)</span><br><span class="line">            logger.info(<span class="string">"[Epoch &#123;&#125;] Set learning rate to &#123;&#125;"</span>.format(epoch, new_lr))</span><br><span class="line">        <span class="keyword">for</span> metric <span class="keyword">in</span> metrics:</span><br><span class="line">            metric.reset()</span><br><span class="line">        tic = time.time()</span><br><span class="line">        btic = time.time()</span><br><span class="line">        net.hybridize(static_alloc=<span class="keyword">True</span>)</span><br><span class="line">        base_lr = trainer.learning_rate</span><br><span class="line">        <span class="keyword">for</span> i, batch <span class="keyword">in</span> enumerate(train_data):</span><br><span class="line">            <span class="keyword">if</span> epoch == <span class="number">0</span> <span class="keyword">and</span> i &lt;= lr_warmup:</span><br><span class="line">                new_lr = base_lr * get_lr_at_iter((i // <span class="number">500</span>) / (lr_warmup / <span class="number">500.</span>))</span><br><span class="line">                <span class="keyword">if</span> new_lr != trainer.learning_rate:</span><br><span class="line">                    logger.info(<span class="string">'[Epoch 0 Iteration &#123;&#125;] Set learning rate to &#123;&#125;'</span>.format(i, new_lr))</span><br><span class="line">                    trainer.set_learning_rate(new_lr)</span><br><span class="line">            batch = split_and_load(batch, ctx_list=ctx)</span><br><span class="line">            batch_size = len(batch[<span class="number">0</span>])</span><br><span class="line">            losses = []</span><br><span class="line">            metric_losses = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> metrics]</span><br><span class="line">            add_losses = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> metrics2]</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                <span class="keyword">for</span> data, label, rpn_cls_targets, rpn_box_targets, rpn_box_masks <span class="keyword">in</span> zip(*batch):</span><br><span class="line">                    gt_label = label[:, :, <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">                    gt_box = label[:, :, :<span class="number">4</span>]</span><br><span class="line">                    cls_pred, box_pred, roi, samples, matches, rpn_score, rpn_box, anchors = net(data, gt_box)</span><br><span class="line">                    <span class="comment"># losses of rpn</span></span><br><span class="line">                    rpn_score = rpn_score.squeeze(axis=<span class="number">-1</span>)</span><br><span class="line">                    <span class="comment"># 得出target中正负样本的数量</span></span><br><span class="line">                    num_rpn_pos = (rpn_cls_targets &gt;= <span class="number">0</span>).sum()</span><br><span class="line">                    <span class="comment"># rpn score loss</span></span><br><span class="line">                    rpn_loss1 = rpn_cls_loss(rpn_score, rpn_cls_targets, rpn_cls_targets &gt;= <span class="number">0</span>) * rpn_cls_targets.size / num_rpn_pos</span><br><span class="line">                    <span class="comment"># rpn bounding loss</span></span><br><span class="line">                    rpn_loss2 = rpn_box_loss(rpn_box, rpn_box_targets, rpn_box_masks) * rpn_box.size / num_rpn_pos</span><br><span class="line">                    <span class="comment"># rpn overall loss, use sum rather than average</span></span><br><span class="line">                    rpn_loss = rpn_loss1 + rpn_loss2</span><br><span class="line">                    <span class="comment"># generate targets for rcnn</span></span><br><span class="line">                    <span class="comment"># 产生RCNN部分的target </span></span><br><span class="line">                    <span class="comment"># cls_targets shape=(128,) box_targets shape=(128*20*4) box_masks=(128*20*4)</span></span><br><span class="line">                    cls_targets, box_targets, box_masks = net.target_generator(roi, samples, matches, gt_label, gt_box)</span><br><span class="line">                    <span class="comment"># losses of rcnn</span></span><br><span class="line">                    <span class="comment"># 得到正负样本总数</span></span><br><span class="line">                    num_rcnn_pos = (cls_targets &gt;= <span class="number">0</span>).sum()</span><br><span class="line">                    <span class="comment"># cls的交叉熵损失</span></span><br><span class="line">                    rcnn_loss1 = rcnn_cls_loss(cls_pred, cls_targets, cls_targets &gt;= <span class="number">0</span>) * cls_targets.size / cls_targets.shape[<span class="number">0</span>] / num_rcnn_pos</span><br><span class="line">                    <span class="comment"># bounding的损失</span></span><br><span class="line">                    rcnn_loss2 = rcnn_box_loss(box_pred, box_targets, box_masks) * box_pred.size / box_pred.shape[<span class="number">0</span>] / num_rcnn_pos</span><br><span class="line">                    rcnn_loss = rcnn_loss1 + rcnn_loss2</span><br><span class="line">                    <span class="comment"># overall losses</span></span><br><span class="line">                    losses.append(rpn_loss.sum() + rcnn_loss.sum())</span><br><span class="line">                    metric_losses[<span class="number">0</span>].append(rpn_loss1.sum())</span><br><span class="line">                    metric_losses[<span class="number">1</span>].append(rpn_loss2.sum())</span><br><span class="line">                    metric_losses[<span class="number">2</span>].append(rcnn_loss1.sum())</span><br><span class="line">                    metric_losses[<span class="number">3</span>].append(rcnn_loss2.sum())</span><br><span class="line">                    add_losses[<span class="number">0</span>].append([[rpn_cls_targets, rpn_cls_targets&gt;=<span class="number">0</span>], [rpn_score]])</span><br><span class="line">                    add_losses[<span class="number">1</span>].append([[rpn_box_targets, rpn_box_masks], [rpn_box]])</span><br><span class="line">                    add_losses[<span class="number">2</span>].append([[cls_targets], [cls_pred]])</span><br><span class="line">                    add_losses[<span class="number">3</span>].append([[box_targets, box_masks], [box_pred]])</span><br><span class="line">                autograd.backward(losses)</span><br><span class="line">                <span class="keyword">for</span> metric, record <span class="keyword">in</span> zip(metrics, metric_losses):</span><br><span class="line">                    metric.update(<span class="number">0</span>, record)</span><br><span class="line">                <span class="keyword">for</span> metric, records <span class="keyword">in</span> zip(metrics2, add_losses):</span><br><span class="line">                    <span class="keyword">for</span> pred <span class="keyword">in</span> records:</span><br><span class="line">                        metric.update(pred[<span class="number">0</span>], pred[<span class="number">1</span>])</span><br><span class="line">            trainer.step(batch_size)</span><br><span class="line">            <span class="comment"># update metrics</span></span><br><span class="line">            <span class="keyword">if</span> args.log_interval <span class="keyword">and</span> <span class="keyword">not</span> (i + <span class="number">1</span>) % args.log_interval:</span><br><span class="line">                <span class="comment"># msg = ','.join(['&#123;&#125;=&#123;:.3f&#125;'.format(*metric.get()) for metric in metrics])</span></span><br><span class="line">                msg = <span class="string">','</span>.join([<span class="string">'&#123;&#125;=&#123;:.3f&#125;'</span>.format(*metric.get()) <span class="keyword">for</span> metric <span class="keyword">in</span> metrics + metrics2])</span><br><span class="line">                logger.info(<span class="string">'[Epoch &#123;&#125;][Batch &#123;&#125;], Speed: &#123;:.3f&#125; samples/sec, &#123;&#125;'</span>.format(</span><br><span class="line">                    epoch, i, batch_size/(time.time()-btic), msg))</span><br><span class="line">            btic = time.time()</span><br><span class="line"></span><br><span class="line">        msg = <span class="string">','</span>.join([<span class="string">'&#123;&#125;=&#123;:.3f&#125;'</span>.format(*metric.get()) <span class="keyword">for</span> metric <span class="keyword">in</span> metrics])</span><br><span class="line">        logger.info(<span class="string">'[Epoch &#123;&#125;] Training cost: &#123;:.3f&#125;, &#123;&#125;'</span>.format(</span><br><span class="line">            epoch, (time.time()-tic), msg))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (epoch + <span class="number">1</span>) % args.val_interval:</span><br><span class="line">            <span class="comment"># consider reduce the frequency of validation to save time</span></span><br><span class="line">            map_name, mean_ap = validate(net, val_data, ctx, eval_metric)</span><br><span class="line">            val_msg = <span class="string">'\n'</span>.join([<span class="string">'&#123;&#125;=&#123;&#125;'</span>.format(k, v) <span class="keyword">for</span> k, v <span class="keyword">in</span> zip(map_name, mean_ap)])</span><br><span class="line">            logger.info(<span class="string">'[Epoch &#123;&#125;] Validation: \n&#123;&#125;'</span>.format(epoch, val_msg))</span><br><span class="line">            current_map = float(mean_ap[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            current_map = <span class="number">0.</span></span><br><span class="line">        save_params(net, logger, best_map, current_map, epoch, args.save_interval, args.save_prefix)</span><br></pre></td></tr></table></figure>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><script type="math/tex; mode=display">
prob = \frac{1}{1 + \exp(-{pred})} \\
L = - \sum_i {label}_i * \log({prob}_i) +
    (1 - {label}_i) * \log(1 - {prob}_i)</script><p>img：reshape、normalzie之后的图像<br>bbox：reshape之后的gt_box<br>cls_target[0]：哪些是正样本，哪些是负样本，哪些需要忽略，跟之前一样，只是降了一个维度<br>box_target[0]：正样本box跟gt_box之间要学习的平移和缩放距离，跟之前一样，只是降了一个维度<br>box_mask[0]：box_target对应的mask，跟之前一样，只是降了一个维度<br>return img, bbox.astype(img.dtype), cls_target[0], box_target[0], box_mask[0]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># no need to convert bounding boxes in training, just return</span></span><br><span class="line"><span class="comment"># 训练过程中，返回如下</span></span><br><span class="line"><span class="comment"># cls_pred：全连接网络最后的预测类型</span></span><br><span class="line"><span class="comment"># box_pred: 全连接网络最后的box偏移</span></span><br><span class="line"><span class="comment"># rpn_box：加上lebal的筛选出送入roi poolinglayer的box偏移</span></span><br><span class="line"><span class="comment"># samples：rpn_box是正样本1，还是负样本-1，还是忽略0</span></span><br><span class="line"><span class="comment"># matches：rpn_box匹配哪个样本，-1代表忽略的，其他值是真实类别</span></span><br><span class="line"><span class="comment"># raw_rpn_score：原始产生的box score</span></span><br><span class="line"><span class="comment"># raw_rpn_box：原始产生的box坐标偏移</span></span><br><span class="line"><span class="comment"># anchors：原始产生的anchors</span></span><br><span class="line"><span class="keyword">return</span> (cls_pred, box_pred, rpn_box, samples, matches, raw_rpn_score, raw_rpn_box, anchors)</span><br><span class="line"></span><br><span class="line">cls_pred, box_pred, roi, samples, matches, rpn_score, rpn_box, anchors = net(data, gt_box)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cls_target[0]：哪些是正样本，哪些是负样本，哪些需要忽略，跟之前一样，只是降了一个维度 -1：忽略，0：负样本，1：正样本</span></span><br><span class="line"><span class="comment"># box_target[0]：正样本box跟gt_box之间要学习的平移和缩放距离，跟之前一样，只是降了一个维度</span></span><br><span class="line"><span class="comment"># box_mask[0]：box_target对应的mask，跟之前一样，只是降了一个维度</span></span><br><span class="line"><span class="keyword">return</span> img, bbox.astype(img.dtype), cls_target[<span class="number">0</span>], box_target[<span class="number">0</span>], box_mask[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data, label, rpn_cls_targets, rpn_box_targets, rpn_box_masks <span class="keyword">in</span> zip(*batch):</span><br><span class="line"></span><br><span class="line"><span class="comment"># rpn网络预测的正负样本，target正负样本，loss</span></span><br><span class="line">rpn_loss1 = rpn_cls_loss(rpn_score, rpn_cls_targets, rpn_cls_targets &gt;= <span class="number">0</span>) * rpn_cls_targets.size / num_rpn_pos</span><br><span class="line"><span class="comment"># rpn预测到的box偏移与缩放，target box的偏移与缩放，loss</span></span><br><span class="line">rpn_loss2 = rpn_box_loss(rpn_box, rpn_box_targets, rpn_box_masks) * rpn_box.size / num_rpn_pos</span><br><span class="line"><span class="comment"># roi</span></span><br><span class="line">cls_targets, box_targets, box_masks = net.target_generator(roi, samples, matches, gt_label, gt_box)</span><br></pre></td></tr></table></figure>
<h2 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h2><h2 id="损失计算"><a href="#损失计算" class="headerlink" title="损失计算"></a>损失计算</h2><ol>
<li><p>rpn网络产生的box是前景还是背景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpn_score：原始的box得分，没有经过sigmoid，例如shape=1*18500</span></span><br><span class="line"><span class="comment"># rpn_cls_targets：这些box哪些应该是前景1，哪些是背景0，哪些应该忽略-1</span></span><br><span class="line"><span class="comment"># rpn_cls_targets&gt;=0：表示只给前景和背景计算loss，-1的不计算loss</span></span><br><span class="line">rpn_cls_loss = mx.gluon.loss.SigmoidBinaryCrossEntropyLoss(from_sigmoid=<span class="keyword">False</span>)</span><br><span class="line">rpn_loss1 = rpn_cls_loss(rpn_score, rpn_cls_targets, rpn_cls_targets &gt;= <span class="number">0</span>) * rpn_cls_targets.size / num_rpn_pos</span><br></pre></td></tr></table></figure>
</li>
<li><p>rpn网络产生的box的平移缩放损失。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpn_box：原始的平移和缩放</span></span><br><span class="line"><span class="comment"># rpn_box_targets：期望的前景的平移与缩放</span></span><br><span class="line"><span class="comment"># rpn_box_masks：rpn_box_targets的mask，就是说只计算前景的loss，因为背景不能计算</span></span><br><span class="line">rpn_loss2 = rpn_box_loss(rpn_box, rpn_box_targets, rpn_box_masks) * rpn_box.size / num_rpn_pos</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h1><p>这里构造评价器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">metrics = [mx.metric.Loss(<span class="string">'RPN_Conf'</span>),</span><br><span class="line">           mx.metric.Loss(<span class="string">'RPN_SmoothL1'</span>),</span><br><span class="line">           mx.metric.Loss(<span class="string">'RCNN_CrossEntropy'</span>),</span><br><span class="line">           mx.metric.Loss(<span class="string">'RCNN_SmoothL1'</span>),]</span><br><span class="line"></span><br><span class="line">rpn_acc_metric = RPNAccMetric()</span><br><span class="line">rpn_bbox_metric = RPNL1LossMetric()</span><br><span class="line">rcnn_acc_metric = RCNNAccMetric()</span><br><span class="line">rcnn_bbox_metric = RCNNL1LossMetric()</span><br><span class="line">metrics2 = [rpn_acc_metric, rpn_bbox_metric, rcnn_acc_metric, rcnn_bbox_metric]</span><br></pre></td></tr></table></figure></p>
<p>每一个batch，都会有这么两个局部变量，即list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metric_losses = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> metrics]</span><br><span class="line">add_losses = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> metrics2]</span><br></pre></td></tr></table></figure></p>
<p>得到一个batch的loss之后，将各个loss加入到对应的list，然后在update各自的metric<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">metric_losses[<span class="number">0</span>].append(rpn_loss1.sum())</span><br><span class="line">metric_losses[<span class="number">1</span>].append(rpn_loss2.sum())</span><br><span class="line">metric_losses[<span class="number">2</span>].append(rcnn_loss1.sum())</span><br><span class="line">metric_losses[<span class="number">3</span>].append(rcnn_loss2.sum())</span><br><span class="line">add_losses[<span class="number">0</span>].append([[rpn_cls_targets, rpn_cls_targets&gt;=<span class="number">0</span>], [rpn_score]])</span><br><span class="line">add_losses[<span class="number">1</span>].append([[rpn_box_targets, rpn_box_masks], [rpn_box]])</span><br><span class="line">add_losses[<span class="number">2</span>].append([[cls_targets], [cls_pred]])</span><br><span class="line">add_losses[<span class="number">3</span>].append([[box_targets, box_masks], [box_pred]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> metric, record <span class="keyword">in</span> zip(metrics, metric_losses):</span><br><span class="line">    metric.update(<span class="number">0</span>, record)</span><br><span class="line"><span class="keyword">for</span> metric, records <span class="keyword">in</span> zip(metrics2, add_losses):</span><br><span class="line">    <span class="keyword">for</span> pred <span class="keyword">in</span> records:</span><br><span class="line">        metric.update(pred[<span class="number">0</span>], pred[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>持续技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="乡间小路 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/目标检测/" rel="tag"># 目标检测</a>
          
            <a href="/tags/RCNN/" rel="tag"># RCNN</a>
          
            <a href="/tags/Faster-RCNN/" rel="tag"># Faster RCNN</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/16/Linux_Knowledge/" rel="next" title="linux知识积累">
                <i class="fa fa-chevron-left"></i> linux知识积累
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/19/Linux_Problems_And_Solutions/" rel="prev" title="linux遇到的问题">
                linux遇到的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjg4MS8xMzQxNw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="乡间小路" />
            
              <p class="site-author-name" itemprop="name">乡间小路</p>
              <p class="site-description motion-element" itemprop="description">把知道的东西讲清楚</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">95</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                推荐博客
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.flickering.cn/" title="火光摇曳" target="_blank">火光摇曳</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.wulc.me/" title="吴良超的学习笔记" target="_blank">吴良超的学习笔记</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/pinard/" title="刘建平Pinard" target="_blank">刘建平Pinard</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://mlnote.com/" title="水滴石穿" target="_blank">水滴石穿</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/makefile/" title="明也无涯" target="_blank">明也无涯</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://noahsnail.com/" title="SnailTyan" target="_blank">SnailTyan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://lanbing510.info/" title="求知若饥，知行合一" target="_blank">求知若饥，知行合一</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://saicoco.github.io/" title="Fix you" target="_blank">Fix you</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qiankun214.github.io/" title="月见樽" target="_blank">月见樽</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jacobkong.github.io/" title="Jacob Kong" target="_blank">Jacob Kong</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/xuanyuyt/" title="xuanyuyt" target="_blank">xuanyuyt</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/sinat_26917383" title="悟乙己" target="_blank">悟乙己</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/julialove102123" title="女王的宫殿" target="_blank">女王的宫殿</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://frankchen.xyz/" title="不正经数据科学家" target="_blank">不正经数据科学家</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/victoriaw" title="CodeTutor" target="_blank">CodeTutor</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://deepsystems.ai/" title="Deep Systems" target="_blank">Deep Systems</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://medium.com/@jonathan_hui" title="Jonathan Hui" target="_blank">Jonathan Hui</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/zhangchaoyang/" title="Orisun" target="_blank">Orisun</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/511ba5d71aef" title="milter" target="_blank">milter</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/mrlevo520" title="MrLevo520的博客" target="_blank">MrLevo520的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://speech.ee.ntu.edu.tw/~tlkagk/talk.html" title="李宏毅主页" target="_blank">李宏毅主页</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/qq_37059483" title="qingyun_wudaoletu的博客" target="_blank">qingyun_wudaoletu的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://liam0205.me/" title="始终" target="_blank">始终</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/grandyang/" title="Grandyang" target="_blank">Grandyang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://littlehaes.com/" title="Hae's Blog" target="_blank">Hae's Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/ed6d4d31c5b0" title="月牙眼的楼下小黑" target="_blank">月牙眼的楼下小黑</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hanlongfei.com/" title="Longfei Han" target="_blank">Longfei Han</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/bitcarmanlee" title="bitcarmanlee的博客" target="_blank">bitcarmanlee的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/lanchunhui" title="Zhang's Wikipedia" target="_blank">Zhang's Wikipedia</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://samaelchen.github.io/" title="碎碎念" target="_blank">碎碎念</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/jiange_zh" title="jiange_zh" target="_blank">jiange_zh</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/bitcs_zt" title="ZSYGOOOD" target="_blank">ZSYGOOOD</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://buptwc.github.io/" title="演员的自我修养" target="_blank">演员的自我修养</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://freemind.pluskid.org/" title="Free Mind" target="_blank">Free Mind</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://me.csdn.net/icefire_tyh" title="四去六进一" target="_blank">四去六进一</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RPN网络"><span class="nav-number">1.</span> <span class="nav-text">RPN网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#生成anchors"><span class="nav-number">1.1.</span> <span class="nav-text">生成anchors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPNProposal类详解"><span class="nav-number">1.2.</span> <span class="nav-text">RPNProposal类详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RCNNTargetSampler"><span class="nav-number">1.3.</span> <span class="nav-text">RCNNTargetSampler</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">2.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#target怎么来"><span class="nav-number">3.</span> <span class="nav-text">target怎么来</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#采样正样本和负样本"><span class="nav-number">3.1.</span> <span class="nav-text">采样正样本和负样本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#-1"><span class="nav-number">4.</span> <span class="nav-text">#</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#训练"><span class="nav-number">4.1.</span> <span class="nav-text">训练</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#损失函数"><span class="nav-number">4.2.</span> <span class="nav-text">损失函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#损失函数-1"><span class="nav-number">4.3.</span> <span class="nav-text">损失函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#损失计算"><span class="nav-number">4.4.</span> <span class="nav-text">损失计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#评价标准"><span class="nav-number">5.</span> <span class="nav-text">评价标准</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乡间小路</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
